<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>「学习笔记」CSS基础 | lzh-zone</title><meta name="author" content="Sterling"><meta name="copyright" content="Sterling"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言本篇文章着重梳理之前所学的CSS知识点，查漏补缺。同时，试着用git将重点案例存放到远程仓库中，更近一步贴近公司流程。💪💪 CSS构造块「1. HTML的局限性」 HTML满足不了设计者的需求，可以将网页结构与样式相分离，这样就可以在不更改网页结构的前提下，更换网站的样式。操作html属性不方便HTML里面添加样式带来的是无尽的臃肿和繁琐「2. CSS网页的美容师」 让我们的网页更加丰富多">
<meta property="og:type" content="article">
<meta property="og:title" content="「学习笔记」CSS基础">
<meta property="og:url" content="http://example.com/2022/04/03/css%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="lzh-zone">
<meta property="og:description" content="前言本篇文章着重梳理之前所学的CSS知识点，查漏补缺。同时，试着用git将重点案例存放到远程仓库中，更近一步贴近公司流程。💪💪 CSS构造块「1. HTML的局限性」 HTML满足不了设计者的需求，可以将网页结构与样式相分离，这样就可以在不更改网页结构的前提下，更换网站的样式。操作html属性不方便HTML里面添加样式带来的是无尽的臃肿和繁琐「2. CSS网页的美容师」 让我们的网页更加丰富多">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2022/03/28/zXHY3nC2V7vguRT.png">
<meta property="article:published_time" content="2022-04-03T07:50:00.000Z">
<meta property="article:modified_time" content="2022-04-03T12:16:36.262Z">
<meta property="article:author" content="Sterling">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2022/03/28/zXHY3nC2V7vguRT.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/04/03/css%E5%9F%BA%E7%A1%80/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '「学习笔记」CSS基础',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-04-03 20:16:36'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/nav_menu.css"><link rel="stylesheet" href="/css/APlayer.min.css"><link rel="stylesheet" href="/css/music.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/mainColor/heoMainColor.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/poem/poem.css"><link rel="stylesheet" href="/css/zhihu.css"><link rel="stylesheet" href="/css/card_author.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="lzh-zone" type="application/atom+xml">
</head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="/css/progress_bar.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/qq.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2022/03/28/zXHY3nC2V7vguRT.png')"><nav id="nav"><span id="blog-info"><a href="/" title="lzh-zone"><img class="site-icon" src="/img/logo.png#%20image"/><span class="site-name">lzh-zone</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">「学习笔记」CSS基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-04-03T07:50:00.000Z" title="发表于 2022-04-03 15:50:00">2022-04-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-03T12:16:36.262Z" title="更新于 2022-04-03 20:16:36">2022-04-03</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="「学习笔记」CSS基础"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>前言<br>本篇文章着重梳理之前所学的CSS知识点，查漏补缺。同时，试着用git将重点案例存放到远程仓库中，更近一步贴近公司流程。💪💪</p>
<p>CSS构造块<br>「1. HTML的局限性」</p>
<p>HTML满足不了设计者的需求，可以将网页结构与样式相分离，这样就可以在不更改网页结构的前提下，更换网站的样式。<br>操作html属性不方便<br>HTML里面添加样式带来的是无尽的臃肿和繁琐<br>「2. CSS网页的美容师」</p>
<p>让我们的网页更加丰富多彩，布局更加灵活自如。<br>CSS最大的贡献：让HTML从样式中脱离，实现了HTML专注去做结构呈现，样式交给CSS<br>「3. CSS」CSS(Cascading Style Sheets)通常称为CSS样式表或层叠样式表(级联样式表)。</p>
<p>作用<br>主要用于设置HTML页面中的文本内容(字体、大小、对齐方式等)\图片的外形(宽高、边框样式、边距等)以及版面的布局和外观显示样式。<br>CSS以HTML为基础，提供了丰富的功能，如字体、样式、背景的控制及整体排版等，而且可以针对不同的浏览器设置不同的样式。<br>「4. CSS注释」</p>
<p>&#x2F;* 这是注释 *&#x2F;<br>引入CSS样式表<br>「1.行内式(内联样式)」</p>
<p>通过标签的style属性来设置元素的样式</p>
<p>style其实就是标签的属性<br>样式属性和值中间是:<br>多组属性值直接用;隔开<br>只能控制当前的标签和以及嵌套在其中的字标签，造成代码冗余。<br>缺点:没有实现样式和结构相分离。<br>&lt;标签名 style&#x3D;”属性1:属性值1; 属性2:属性值2; 属性3:属性值3;”&gt; 内容 &lt;&#x2F;标签名&gt;<br>例如：</p>
<div style="color: red; font-size: 12px;">青春不常在，抓紧谈恋爱</div>
「2.内部样式表(内嵌样式表)」

<p>也称为内嵌式，将CSS代码集中写在HTML文档的head头部标签中，并且用style标签定义。</p>
<p>style标签一般位于head标签中，当然理论上他可以放在HTML文档的任何地方。<br>type&#x3D;”text&#x2F;css”  在html5中可以省略。<br>只能控制当前的页面<br>缺点:没有彻底分离结构与样式</p>
<head>
<style type="text/CSS">
    选择器（选择的标签） { 
      属性1: 属性值1;
      属性2: 属性值2; 
      属性3: 属性值3;
    }
</style>
</head>
「3.外部样式表(外链式)」

<p>也称链入式，是将所有的样式放在一个或多个以.css为扩展名的外部样式表文件中，通过link标签将外部样式表文件链接到HTML文档中。</p>
<p>rel:定义当前文档与被链接文档之间的关系，在这里需要指定为“stylesheet”，表示被链接的文档是一个样式表文件。<br>href:定义所链接外部样式表文件的URL，可以是相对路径，也可以是绝对路径。</p>
<link rel="stylesheet" href="index.css">
「4.团队约定-代码风格」

<p>&#x2F;<em>1.紧凑格式 (Compact)</em>&#x2F;<br>h3 { color: deeppink;font-size: 20px;}<br>&#x2F;&#x2F; 2.一种是展开格式（推荐）<br>h3 {<br> color: deeppink;<br>    font-size: 20px;<br>}</p>
<p>&#x2F;* 团队约定-代码大小写*&#x2F;<br>&#x2F;* 样式选择器，属性名，属性值关键字全部使用小写字母书写，属性字符串允许使用大小写。*&#x2F;<br>&#x2F;* 推荐 *&#x2F;<br>h3{<br> color: pink;<br>}</p>
<p>&#x2F;* 不推荐 *&#x2F;<br>H3{<br> COLOR: PINK;<br>}</p>
<p>CSS基础选择器<br>CSS选择器作用<br>找到指定的HTML页面元素，选择标签。</p>
<p>CSS基础选择器<br>「1. 标签选择器」</p>
<p>标签选择器（元素选择器）是指用HTML标签名称作为选择器，按标签名称分类，为页面中某一类标签指定统一的CSS样式。<br>作用：可以把某一类标签全部选择出来。<br>优点：快速为网页中同类型的标签统一样式<br>缺点：不能设计差异化样式。<br>标签名{属性1:属性值1; 属性2:属性值2; 属性3:属性值3; }<br>「2. 类选择器」</p>
<p>类选择器使用”.”(英文点号)进行标识，后面紧跟类名。<br>语法：类名选择器<br>.类名  {<br>    属性1:属性值1;<br>    属性2:属性值2;<br>    属性3:属性值3;<br>}</p>
<p class='类名'></p>
优点：可以为元素对象定义单独或相同的样式。可以选择一个或者多个标签。
注意：类选择器使用“.”（英文点号）进行标识，后面紧跟类名(自定义，我们自己命名的)
长名称或词组可以使用中横线来为选择器命名。
不要纯数字、中文等命名， 尽量使用英文字母来表示。
多类名选择器：各个类名中间用空格隔开。
「3. id选择器」id选择器使用#进行标识，后面紧跟id名

<p>元素的id值是唯一的，只能对应于文档中某一个具体的元素。<br>#id名 {属性1:属性值1; 属性2:属性值2; 属性3:属性值3; }</p>
<p id="id名"></p>
「4. 通配符选择器」

<p>通配符选择器用<em>号表示，</em> 就是选择所有的标签。它是所有选择器中作用范围最广的，能匹配页面中所有的元素。</p>
<p>注意：会匹配页面所有的元素，降低页面响应速度，不建议随便使用</p>
<ul>
<li><p>{ 属性1:属性值1; 属性2:属性值2; 属性3:属性值3; }<br>例如下面代码，使用通配符选择器定义CSS样式，清除所有HTML标记的默认边距。</p>
</li>
<li><p>{<br>margin: 0;                    &#x2F;* 定义外边距*&#x2F;<br>padding: 0;                   &#x2F;* 定义内边距*&#x2F;<br>}<br>「5. 基础选择器总结」</p>
</li>
</ul>
<p>选择器	作用	缺点	使用情况	用法<br>标签选择器	可以选出所有相同的标签，比如p	不能差异化选择	较多	p { color：red;}<br>类选择器	可以选出1个或者多个标签	可以根据需求选择	非常多	.nav { color: red; }<br>id选择器	一次只能选择器1个标签	只能使用一次	不推荐使用	#nav {color: red;}<br>通配符选择器	选择所有的标签	选择的太多，有部分不需要	不推荐使用	* {color: red;}<br>「6. 团队约定-选择器」</p>
<p>尽量少用通配符选择器 <em>。<br>尽量少用ID选择器<br>不使用无具体语义定义的标签选择器。<br>&#x2F;</em> 推荐 *&#x2F;<br>.jdc {}<br>li {}<br>p{}</p>
<p>&#x2F;* 不推荐 *&#x2F;<br>*{}<br>#jdc {}<br>div{}   因为div 没有语义，我们尽量少用</p>
<p>CSS复合选择器<br>复合选择器是由两个或多个基础选择器，通过不同的方式组合而成的</p>
<p>「1. 后代选择器」又称为包含选择器</p>
<p>用来选择元素或元素组的子孙后代<br>其写法就是把外层标签写在前面，内层标签写在后面，中间用「空格」分隔，先写父亲爷爷，再写儿子孙子。<br>子孙后代都可以这么选择。或者说，它能选择任何包含在内 的标签。<br>父级 子级{属性:属性值;属性:属性值;}</p>
<p>.class h3 {color:red;font-size:16px;}<br>图片<br>当标签发生嵌套时，内层标签就成为外层标签的后代。<br>子孙后代都可以这么选择。或者说，它能选择任何包含在内的标签。<br>「2. 子元素选择器」</p>
<p>子元素选择器只能选择作为某元素子元素(亲儿子)的元素。<br>其写法就是把父级标签写在前面，子级标签写在后面，中间跟一个 &gt; 进行连接<br>这里的子,指的是亲儿子。不包含孙子 重孙子之类。<br>.class&gt;h3 {color:red;font-size:14px;}<br>「3. 交集选择器」</p>
<p>图片<br>其中第一个为标签选择器，第二个为class选择器，两个选择器之间不能有空格，如h3.special。<br>交集选择器是并且的意思,即…又…的意思<br>比如：   p.one   选择的是： 类名为 .one 的段落标签。<br>&#x2F;<em>用的相对来说比较少，不建议使用。</em>&#x2F;<br>「4. 并集选择器」如果某些选择器定义的相同样式，就可以利用并集选择器，可以让代码更简洁。并集选择器（CSS选择器分组）是各个选择器通过,连接而成的，通常用于集体声明。</p>
<p>任何形式的选择器（包括标签选择器、class类选择器 id选择器等），都可以作为并集选择器的一部分。<br>并集选择器通常用于集体声明  ，逗号隔开的，所有选择器都会执行后面样式，逗号可以理解为和的意思。<br>比如<br>.one,<br>p ,<br>#test {color: #F00;}<br>表示   .one 和 p  和 #test 这三个选择器都会执行颜色为红色。<br>通常用于集体声明。<br>「5. 链接伪类选择器」</p>
<p>用于向某些选择器添加特殊的效果。写的时候，他们的顺序尽量不要颠倒,按照lvha的顺序。否则可能引起错误。</p>
<p>链接伪类，是利用交集选择器.</p>
<p>a:link  未访问的链接<br>a:visited  已访问的链接<br>a:hover  鼠标移动到链接上<br>a:active  选定的链接<br>实际工作中，很少写全四个状态，一般写法如下：<br>a {   &#x2F;* a是标签选择器  所有的链接 <em>&#x2F;<br>   font-weight: 700;<br>   font-size: 16px;<br>   color: gray;<br>      text-decoration: none; &#x2F;</em> 清除链接默认的下划线*&#x2F;<br>}<br>a:hover {   &#x2F;* :hover 是链接伪类选择器 鼠标经过 <em>&#x2F;<br>   color: red; &#x2F;</em>  鼠标经过的时候，由原来的 灰色 变成了红色 *&#x2F;<br>}<br>「6. 复合选择器总结」</p>
<p>选择器	作用	特征	使用情况	隔开符号及用法<br>后代选择器	用来选择元素后代	是选择所有的子孙后代	较多	符号是空格 .nav a<br>子代选择器	选择 最近一级元素	只选亲儿子	较少	符号是&gt;   .nav&gt;p<br>交集选择器	选择两个标签交集的部分	既是 又是	较少	没有符号  p.one<br>并集选择器	选择某些相同样式的选择器	可以用于集体声明	较多	符号是逗号 .nav, .header<br>链接伪类选择器	给链接更改状态	<br>较多	重点记住 a{} 和 a:hover  实际开发的写法<br>CSS字体样式<br>font字体<br>「1. font-size」</p>
<p>font-size属性用于设置字号(字体大小)<br>谷歌浏览器默认的文字大小为16px<br>不同浏览器可能默认显示的字号大小不一致，我们尽量给一个明确值大小，不要默认大小。一般给body指定整个页面文字的大小。<br>p { font-size:20px; }<br>单位<br>相对长度单位、绝对长度单位<br>图片「2. font-family」</p>
<p>font-family属性用于设置哪一种字体。<br>p { font-family:”微软雅黑”;}<br>指定多个字体，如果浏览器不支持第一个字体就会尝试下一个直到找到合适的字体，如果都没有，以电脑默认字体为准。<br>p {font-family: Arial,”Microsoft Yahei”, “微软雅黑”;}<br>CSS Unicode字体<br>在 CSS 中设置字体名称，直接写中文是可以的。但是在文件编码（GB2312、UTF-8 等）不匹配时会产生乱码的错误。<br>xp 系统不支持 类似微软雅黑的中文。<br>解决方案：英文来替代。比如font-family:”Microsoft Yahei”。在 CSS 直接使用 Unicode 编码来写字体名称可以避免这些错误。使用 Unicode 写中文字体名称，浏览器是可以正确的解析的。<br>font-family: “\5FAE\8F6F\96C5\9ED1”;   表示设置字体为“微软雅黑”。<br>「3. font-weight」</p>
<p>属性值	描述<br>normal	默认值（不加粗的）<br>bold	定义粗体（加粗的）<br>100~900	400 等同于 normal，而 700 等同于 bold  (数字表示粗细用的多)<br>「4. font-weight」</p>
<p>font-style属性用于定义字体风格，如设置斜体、倾斜或正常字体，其可用属性值如下：</p>
<p>属性	作用<br>normal	默认值，浏览器会显示标准的字体样式  font-style: normal;<br>italic	浏览器会显示斜体的字体样式。<br>「5. font:综合设置字体样式」</p>
<p>选择器 { font: font-style  font-weight  font-size&#x2F;line-height  font-family;}<br>注意：使用font属性时，必须按上面语法格式中的顺序书写，不能更换顺序，各个属性以空格隔开<br>其中不需要设置的属性可以省略(取默认值),但必须保留font-size和font-family属性，否则font属性将不起作用。<br>「6. font总结」</p>
<p>属性	表示	注意点<br>font-size	字号	我们通常用的单位是px 像素，一定要跟上单位<br>font-family	字体	实际工作中按照团队约定来写字体<br>font-weight	字体粗细	记住加粗是 700 或者 bold  不加粗 是 normal 或者  400  记住数字不要跟单位<br>font-style	字体样式	记住倾斜是 italic     不倾斜 是 normal  工作中我们最常用 normal<br>font	字体连写	1. 字体连写是有顺序的  不能随意换位置 2. 其中字号 和 字体 必须同时出现<br>CSS外观属性<br>「1. color」</p>
<p>color属性用于定义文本的颜色<br>其取值方式有以下3种：</p>
<p>实际工作中，用16进制的写法是最多的，且我们更喜欢简写方式比如#f0代表红色。<br>表示表示	属性值<br>预定义的颜色值	red，green，blue，pink<br>十六进制	#FF0000，#FF6600，#29D794<br>RGB代码	rgb(255,0,0)或rgb(100%,0%,0%)<br>「2.text-align」</p>
<p>text-align属性用于设置文本内容的水平对齐方式，相当于html中的align对齐属性。</p>
<p>注意：是让盒子里面的文本内容水平居中， 而不是让盒子居中对齐<br>其可用属性值如下：</p>
<p>属性	解释<br>left	左对齐（默认值）<br>right	右对齐<br>center	居中对齐<br>「3. line-height」line-height属性用于设置行间距，就是行与行之间的距离，即字符的垂直间距，一般称为行高。</p>
<p>line-height常用的属性值单位有三种，分别为像素px，相对值em和百分比%，实际工作中使用最多的是像素px<br>一般情况下，行距比字号大7–8像素左右就可以了。<br>line-height: 24px;<br>行高测量<br>行高测量方法：图片</p>
<p>图片行高测量方法行高我们利用最多的一个地方是：可以让单行文本在盒子中垂直居中对齐。</p>
<p>文字的行高等于盒子的高度。行高   &#x3D;  上距离 +  内容高度  + 下距离<br>上距离和下距离总是相等的，因此文字看上去是垂直居中的。</p>
<p>图片<br>行高与高度的三种关系<br>如果 行高 等 高度  文字会 垂直居中<br>如果行高 大于 高度   文字会 偏下<br>如果行高小于高度   文字会  偏上<br>  &#x2F;<em>line-height 要设置在font属性下面，否则无效，例如：</em>&#x2F;<br>  height: 80px;<br>  text-align: center;<br>  font: normal bold 30px “宋体”;<br>  line-height: 80px;<br>可以使用display:flex;布局方式让文字水平垂直居中</p>
<p>  display: flex;<br>  align-items: center;     &#x2F;* 侧轴对齐方式*&#x2F;<br>  justify-content: center; &#x2F;* 主轴对齐方式 *&#x2F;<br>「4. text-indent」</p>
<p>text-indent属性用于设置首行文本的缩进</p>
<p>其属性值可为不同单位的数值、em字符宽度的倍数、或相对于浏览器窗口宽度的百分比%，允许使用负值。<br>建议使用em作为设置单位。<br>1em 就是一个字的宽度。如果是汉字的段落，1em 就是一个汉字的宽度<br>p {<br>      &#x2F;<em>行间距</em>&#x2F;<br>      line-height: 25px;<br>      &#x2F;<em>首行缩进2个字  em  1个em 就是1个字的大小</em>&#x2F;<br>      text-indent: 2em;<br> }<br>「5. text-decoration」文本的装饰</p>
<p>text-decoration,通常我们用于给链接修改装饰效果</p>
<p>值	描述<br>none	默认。定义标准的文本。取消下划线（最常用）<br>underline	定义文本下的一条线。下划线 也是我们链接自带的（常用）<br>overline	定义文本上的一条线。（不用）<br>line-through	定义穿过文本下的一条线。（不常用）<br>「6. CSS外观属性总结」</p>
<p>属性	表示	注意点<br>color	颜色	我们通常用  十六进制   比如 而且是简写形式 #fff<br>line-height	行高	控制行与行之间的距离<br>text-align	水平对齐	可以设定文字水平的对齐方式<br>text-indent	首行缩进	通常我们用于段落首行缩进2个字的距离   text-indent: 2em;<br>text-decoration	文本修饰	记住 添加 下划线  underline  取消下划线  none</p>
<p>标签显示模式(display)<br>标签显示模式是标签以什么方式进行显示。HTML标签一般分为块标签和行内标签两种类型，它们也称为块元素和行内元素。</p>
<p>标签显示模式转换 display<br>块转行内：display:inline;<br>行内转块：display:block;<br>块、行内元素转换为行内块：display: inline-block;<br>「1. 块级元素(block-level)」</p>
<p>常见的块元素有*<h1>**<h6>*、<p>、<div>、<ul>、<ol>、<li>等，其中<div>标签是最典型的块元素。</p>
<p>块级元素的特点<br>独占一行<br>高度，宽度，外边距以及内边距都可以控制。<br>宽度默认是容器(父级宽度)的100%<br>是一个容器及盒子，里面可以放行内或者块级元素<br>注意：只有文字才能组成段落，因此p标签里面不能放块级元素，特别是p不能放div。同理，还有h1~h6，dt,它们都是文字类块级标签，里面不能放其他块级元素。<br>「2. 行内元素(inline-level)」</p>
<p>有的地方也称为内联元素</p>
<p>常见的行内元素有&#x2F;*<a>、<strong>、<b>、<em>、<i>、<del>、<s>、<ins>、<u>、<span>#等，其中<span>标签最典型的行内元素。</p>
<p>行内元素的特点<br>相邻行内元素在一行上，一行可以显示多个。<br>高度、宽度直接设置是无效的。<br>默认高度就是它本身内容的宽度。<br>行内元素只能容纳文本或其他行内元素。<br>注意<br>链接里面不能再放链接<br>特殊情况a里面可以放块级元素，但是给a转换一下块级模式最安全。<br>「3. 行内块元素(inline-block)」</p>
<p>在行内元素中有几个特殊的标签——<img>、<input >、<td>，可以对它们设置宽高和对齐属性，有些资料可能会称它们为行内块元素。</p>
<p>行内块元素的特点<br>和相邻行内元素(行内块)在一行上，但是之间会有空白风险。一行可以显示多个<br>默认宽度就是它本身内容的宽度。<br>高度，行高，外边距以及内边距都可以控制。<br>三种模式总结<br>元素模式	元素排列	设置样式	默认宽度	包含<br>块级元素	一行只能放一个块级元素	可以设置宽度高度	容器的100%	容器级可以包含任何标签<br>行内元素	一行可以放多个行内元素	不可以直接设置宽度高度	它本身内容的宽度	容纳文本或则其他行内元素<br>行内块元素	一行放多个行内块元素	可以设置宽度和高度	它本身内容的宽度	</p>
<p>CSS背景(background)<br>「1. 背景颜色」</p>
<p>background-color: 颜色值;   默认的值是 transparent  透明的<br>「2. 背景图片(image)」</p>
<p>语法：<br>background-image : none | url (url) ;<br>例如:<br>background-image: url(images&#x2F;1.png);<br>「3. 背景平铺（repeat）」</p>
<p>background-repeat : repeat | no-repeat | repeat-x | repeat-y<br>参数	作用<br>repeat	背景图像在纵向和横向上平铺（默认的）<br>no-repeat	背景图像不平铺<br>repeat-x	背景图像在横向上平铺<br>repeat-y	背景图像在纵向平铺<br>「4. 背景位置(position)」</p>
<p>background-position : length || length<br>background-position : position || position<br>参数	值<br>length	百分数 | 由浮点数字和单位标识符组成的长度值<br>position	top | center | bottom | left | center | right   方位名词<br>注意：<br>必须先指定background-image属性<br>position 后面是x坐标和y坐标。可以使用方位名词或者 精确单位。<br>如果指定两个值，两个值都是方位名字，则两个值前后顺序无关，比如left  top和top  left效果一致<br>如果只指定了一个方位名词，另一个值默认居中对齐。<br>如果position 后面是精确坐标， 那么第一个，肯定是 x 第二个一定是y<br>如果只指定一个数值,那该数值一定是x坐标，另一个默认垂直居中<br>如果指定的两个值是 精确单位和方位名字混合使用，则第一个值是x坐标，第二个值是y坐标<br>背景简写：<br>background：属性的值的书写顺序官方没有强制的标准。为了可读性，建议如下写：<br>background: 背景颜色 背景图片地址 背景平铺 背景滚动 背景位置;<br>&#x2F;* 有背景图片背景颜色可以不用写*&#x2F;<br>background: transparent url(image.jpg) repeat-y  scroll center top ;<br>「5. 背景半透明(CSS3)」</p>
<p>background: rgba(0, 0, 0, 0.3);<br>background: rgba(0, 0, 0, .3);<br>等同于background-color: rgba(0, 0, 0, .3)<br>最后一个参数是alpha 透明度  取值范围 0~1之间<br>我们习惯把0.3 的 0 省略掉  这样写 background: rgba(0, 0, 0, .3);<br>注意：背景半透明是指盒子背景半透明，盒子里面的内容不受影响<br>低于IE 9的版本不支持<br>盒子半透明 opacity<br>设置opacity元素的所有后代元素会随着一起具有透明性，一般用于调整图片或者模块的整体不透明度<br>opacity: .2;<br>「6. 背景总结」</p>
<p>属性	作用	值<br>background-color	背景颜色	预定义的颜色值&#x2F;十六进制&#x2F;RGB代码<br>background-image	背景图片	url(图片路径)<br>background-repeat	是否平铺	repeat&#x2F;no-repeat&#x2F;repeat-x&#x2F;repeat-y<br>background-position	背景位置	length&#x2F;position    分别是x  和 y坐标， 切记 如果有 精确数值单位，则必须按照先X 后Y 的写法<br>background-attachment	背景固定还是滚动	scroll&#x2F;fixed<br>背景简写	更简单	背景颜色 背景图片地址 背景平铺 背景滚动 背景位置;  他们没有顺序<br>背景透明	让盒子半透明	background: rgba(0,0,0,0.3);   后面必须是 4个值</p>
<p>CSS三大特性<br>「1. CSS 层叠性」</p>
<p>图片<br>-概念：</p>
<p>所谓层叠性是指多种CSS样式的叠加<br>是浏览器处理冲突的一个能力,如果一个属性通过两个相同选择器设置到同一个元素上，那么这个时候一个属性就会将另一个属性层叠掉<br>-原则：</p>
<p>样式冲突，遵循的原则是就近原则。 那个样式离着结构近，就执行那个样式。<br>样式不冲突，不会层叠。<br>「2. CSS 继承性」</p>
<p>图片-概念：</p>
<p>子标签会继承父标签的某些样式，如文本颜色和字号。<br>想要设置一个可继承的属性，只需将它应用于父元素即可。<br>-注意：</p>
<p>恰当地使用继承可以简化代码，降低CSS样式的复杂性。比如有很多子级孩子都需要某个样式，可以给父级指定一个，这些孩子继承过来就好了。<br>子元素可以继承父元素的样式（text-，font-，line-这些元素开头的可以继承，以及color属性）<br>「3. CSS 优先级(CSS特殊性)」</p>
<p>图片-概念：定义CSS样式时，经常出现两个或更多规则应用在同一元素上，此时，</p>
<p>选择器相同，则执行层叠性<br>选择器不同，就会出现优先级的问题。<br>-权重计算公式：</p>
<p>标签选择器	计算权重公式<br>继承或者 *	0,0,0,0<br>每个元素（标签选择器）	0,0,0,1<br>每个类，伪类	0,0,1,0<br>每个ID	0,1,0,0<br>每个行内样式 style&#x3D;””	1,0,0,0<br>每个!important  最重要的	∞ 无穷大<br>值从左到右，左面的最大，一级大于一级，数位之间没有进制，级别之间不可超越。<br>关于CSS权重，我们需要一套计算公式来去计算，这个就是 CSS Specificity（特殊性）<br>div { color: pink !important; }<br>-权重叠加：</p>
<p> div ul  li   ——&gt;      0,0,0,3<br> .nav ul li   ——&gt;      0,0,1,2<br> a:hover      —–—&gt;      0,0,1,1<br> .nav a       ——&gt;      0,0,1,1<br>-继承的权重是0：</p>
<p>我们修改样式，一定要看该标签有没有被选中<br>如果选中了，那么以上面的公式来计权重。谁大听谁的。<br>如果没有选中，那么权重是0，因为继承的权重为0.</p>
<p>盒子模型<br>css学习三大重点： css 盒子模型 、 浮动 、 定位  </p>
<p>网页布局的本质</p>
<p>首先利用CSS设置好盒子的大小，然后摆放盒子的位置。<br>最后把网页元素比如文字图片等等，放入盒子里面。</p>
<ol>
<li>盒子模型(Box Model)<br>盒子模型就是把HTML页面中的布局元素看作是一个矩形的盒子，也就是一个盛装内容的容器。<br>盒子模型由元素的内容、边框（border）、内边距（padding）、和外边距（margin）组成。<br>盒子里面的文字和图片等元素是 内容区域<br>盒子的厚度 我们称为为盒子的边框<br>盒子内容与边框的距离是内边距<br>盒子与盒子之间的距离是外边距<br>W3c标准盒子模型</li>
</ol>
<p>标准 w3c 盒子模型的范围包括 margin、border、padding、content</p>
<p>当设置为box-sizing: content-box;时，将采用标准模式解析计算，也是默认模式；</p>
<p>内盒尺寸计算(元素实际大小)</p>
<p>宽度：Element Height &#x3D; content height + padding + border （Height为内容高度）<br>高度：Element  Width &#x3D; content width + padding + border （Width为内容宽度）<br>盒子的实际大小：内容的宽度和高度 +  内边距   +  边框  图片IE盒子模型<br>IE 盒子模型的 content 部分包含了 border 和 pading</p>
<p>当设置为box-sizing: border-box时，将采用怪异模式解析计算；</p>
<ol start="2">
<li>盒子边框(border)<br>属性	作用<br>border-width	定义边框粗细，单位是px<br>border-style	边框的样式<br>border-color	边框颜色<br>边框的样式：</li>
</ol>
<p>none：没有边框即忽略所有边框的宽度（默认值）<br>solid：边框为单实线(最为常用的)<br>dashed：边框为虚线<br>dotted：边框为点线<br>边框综合设置<br>border : border-width || border-style || border-color </p>
<p>border: 1px solid red;  没有顺序要求<br>盒子边框写法总结表：</p>
<p>很多情况下，我们不需要指定4个边框，我们是可以单独给4个边框分别指定的。</p>
<p>上边框	下边框	左边框	右边框<br>border-top-style:样式;	border-bottom-style:样式;	border-left-style:样式;	border-right-style:样式;<br>border-top-width:宽度;	border- bottom-width:宽度;	border-left-width:宽度;	border-right-width:宽度;<br>border-top-color:颜色;	border- bottom-color:颜色;	border-left-color:颜色;	border-right-color:颜色;<br>border-top:宽度 样式 颜色;	border-bottom:宽度 样式 颜色;	border-left:宽度 样式 颜色;	border-right:宽度 样式 颜色;<br>表格的细线边框：</p>
<p>图片<br>通过表格的cellspacing&#x3D;”0”,将单元格与单元格之间的距离设置为0，<br>但是两个单元格之间的边框会出现重叠，从而使边框变粗<br>通过css属性：table{ border-collapse:collapse; }<br>collapse 单词是合并的意思,border-collapse: collapse;表示相邻边框合并在一起。</p>
<style>
 table {
  width: 500px;
  height: 300px;
  border: 1px solid red;
 }
 td {
  border: 1px solid red;
  text-align: center;
 }
 table, td {
  border-collapse: collapse;  /*合并相邻边框*/
 }
</style>
<ol start="2">
<li>内边距(padding)<br>padding属性用于设置内边距。是指边框与内容之间的距离。</li>
</ol>
<p>设置</p>
<p>属性	作用<br>padding-left	左内边距<br>padding-right	右内边距<br>padding-top	上内边距<br>padding-bottom	下内边距<br>padding简写</p>
<p>值的个数	表达意思<br>1个值	padding：上下左右内边距;<br>2个值	padding: 上下内边距    左右内边距 ；<br>3个值	padding：上内边距   左右内边距   下内边距；<br>4个值	padding: 上内边距 右内边距 下内边距 左内边距 ；<br>当我们给盒子指定padding值之后， 发生了2件事情：</p>
<p>内容和边框 有了距离，添加了内边距。<br>盒子会变大<br>解决措施：通过给设置了宽高的盒子，减去相应的内边距的值，维持盒子原有的大小。</p>
<p>padding不影响盒子大小情况：👉如果没有给一个盒子指定宽度， 此时，如果给这个盒子指定padding， 则不会撑开盒子。</p>
<ol start="3">
<li>外边距（margin）<br>margin属性用于设置外边距。margin就是控制盒子和盒子之间的距离</li>
</ol>
<p>设置</p>
<p>属性	作用<br>margin-left	左外边距<br>margin-right	右外边距<br>margin-top	上外边距<br>margin-bottom	下外边距<br>margin值的简写 （复合写法）代表意思  跟 padding 完全相同。</p>
<p>块级盒子水平居中</p>
<p>盒子必须指定宽度（width）<br>然后就给左右的外边距都设置为auto<br>实际工作中常用这种方式进行网页布局，示例代码如下：</p>
<p>.header  { width: 960px; margin: 0 auto;}<br>常见的写法，以下下三种都可以👇👇。</p>
<p>margin-left: auto;   margin-right: auto;<br>margin: auto;<br>margin: 0 auto;<br>文字居中和盒子居中区别👇👇</p>
<p>盒子内的文字水平居中是 text-align: center; 而且还可以让 行内元素和行内块居中对齐<br>块级盒子水平居中  左右margin 改为 auto<br>插入图片和背景图片区别👇👇</p>
<p>插入图片我们用的最多 比如产品展示类  移动位置只能靠盒模型 padding margin<br>背景图片我们一般用于小图标背景或者超大背景图片、背景图片，移动位置只能通过  background-position<br>清除元素的默认内外边距👇👇</p>
<p>行内元素为了照顾兼容性,尽量只设置左右内外边距，不要设置上下内外边距。</p>
<ul>
<li>{<br> padding:0;         &#x2F;* 清除内边距 <em>&#x2F;<br> margin:0;          &#x2F;</em> 清除外边距 *&#x2F;<br>}<br>4.外边距合并<br>使用margin定义块元素的「垂直外边距」时，可能会出现外边距的合并。</li>
</ul>
<p>(1). 相邻块元素垂直外边距的合并<br>当上下相邻的两个块元素相遇时，如果上面的元素有下外边距margin-bottom<br>下面的元素有上外边距margin-top，则他们之间的垂直间距不是margin-bottom与margin-top之和<br>「取两个值中的较大者」这种现象被称为相邻块元素垂直外边距的合并（也称外边距塌陷）。<br>图片「解决方案：尽量给只给一个盒子添加margin值」。</p>
<p>(2). 嵌套块元素垂直外边距的合并（塌陷）<br>对于两个嵌套关系的块元素，如果父元素没有上内边距及边框<br>父元素的上外边距会与子元素的上外边距发生合并<br>合并后的外边距为两者中的较大者<br>图片「解决方案：」</p>
<p>可以为父元素定义上边框。<br>可以为父元素定义上内边距<br>可以为父元素添加overflow: hidden。<br>还有其他方法，比如浮动、固定、绝对定位的盒子不会有问题，后面咱们再总结。。。</p>
<p>盒子模型布局稳定性<br>优先使用  宽度 （width）  其次 使用内边距（padding）    再次  外边距（margin）</p>
<p>width &gt;  padding  &gt;   margin<br>原因：</p>
<p>margin 会有外边距合并 还有 ie6下面margin 加倍的bug（讨厌）所以最后使用。<br>padding  会影响盒子大小， 需要进行加减计算（麻烦） 其次使用。<br>width   没有问题（嗨皮）我们经常使用宽度剩余法 高度剩余法来做。<br>5. CSS3 新增<br>圆角边框：</p>
<p>border-radius:length;</p>
<p>border-top-left-radius   定义了左上角的弧度<br>border-top-right-radius   定义了右上角的弧度<br>border-bottom-right-radius   定义了右下角的弧度<br>border-bottom-left-radius   定义了左下角的弧度<br>其中每一个值可以为 数值或百分比的形式。<br>技巧：让一个正方形 变成圆圈<br>border-radius: 50%;<br>图片如果要在四个角上一一指定，可以使用以下规则👇👇：</p>
<p>border-radius: 左上角 右上角  右下角  左下角;<br>四个值: 第一个值为左上角，第二个值为右上角，第三个值为右下角，第四个值为左下角。<br>三个值: 第一个值为左上角, 第二个值为右上角和左下角，第三个值为右下角<br>两个值: 第一个值为左上角与右下角，第二个值为右上角与左下角<br>一个值：四个圆角值相同<br>盒子阴影(box-shadow)：</p>
<p>box-shadow: offset-x offset-y [blur [spread]] [color] [inset]<br>值	描述<br>offset-x	阴影的水平偏移量。正数向右偏移，负数向左偏移。<br>offset-y	阴影的垂直偏移量。正数向下偏移，负数向上偏移。<br>blur	可选。阴影模糊距离，不能取负数。<br>spread	可选。阴影大小<br>color	可选。阴影的颜色<br>inset	可选。表示添加内阴影，默认为外阴影<br>div {<br>   width: 200px;<br>   height: 200px;<br>   border: 10px solid red;<br>   &#x2F;* box-shadow: 5px 5px 3px 4px rgba(0, 0, 0, .4);  <em>&#x2F;<br>   &#x2F;</em> box-shadow:水平位置 垂直位置 模糊距离 阴影尺寸（影子大小） 阴影颜色  内&#x2F;外阴影； *&#x2F;<br>   box-shadow: 0 15px 30px  rgba(0, 0, 0, .4);<br>}</p>
<p>浮动<br>浮动<br>「1. CSS布局的三种机制」</p>
<p>网页布局的核心——就是用CSS来摆放盒子。</p>
<p>CSS 提供了3种机制来设置盒子的摆放位置，分别是普通流（标准流）、浮动和定位，其中：</p>
<p>A. 普通流（标准流）</p>
<p>块级元素会独占一行，从上向下顺序排列；<br>常用元素：div、hr、p、h1~h6、ul、ol、dl、form、table<br>行内元素会按照顺序，从左到右顺序排列，碰到父元素边缘则自动换行；<br>常用元素：span、a、i、em等<br>B. 浮动</p>
<p>让盒子从普通流中浮起来,主要作用让多个块级盒子一行显示。<br>C. 定位</p>
<p>将盒子定在浏览器的某一个位置——CSS 离不开定位，特别是后面的 js 特效。<br>「2. 什么是浮动」元素的浮动是指设置了浮动属性的元素会</p>
<p>脱离标准普通流的控制,不占位置，脱标<br>移动到指定位置。<br>作用<br>让多个盒子(div)水平排列成一行，使得浮动称为布局的重要手段。<br>可以实现盒子的左右对齐等等。<br>浮动最早是用来控制图片，实现文字环绕图片效果。<br>float属性会改变元素的display属性，任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。生成的块级框和我们前面的行内块极其相似。<br>语法<br>选择器 { float: 属性值; }<br>属性值	描述<br>none	元素不浮动（默认值）<br>left	元素向左浮动<br>right	元素向右浮动</p>
<p>浮动只会影响当前的或者是后面的标准流盒子，不会影响前面的标准流。<br>建议:如果一个盒子里面有多个子盒子，如果其中一个盒子浮动了，其他兄弟也应该浮动。防止引起问题</p>
<p>图片<br>浮动(float)小结</p>
<p>特点	说明<br>浮	加了浮动的盒子「是浮起来」的，漂浮在其他标准流盒子的上面。<br>漏	加了浮动的盒子「是不占位置的」，它原来的位置「漏给了标准流的盒子」。<br>特	「特别注意」：浮动元素会改变display属性， 类似转换为了行内块，但是元素之间没有空白缝隙<br>清除浮动<br>因为父级盒子很多情况下，不方便给高度，但是子盒子浮动就不占有位置，最后父级盒子高度为0，就影响了下面的标准流盒子。图片图片总结：</p>
<p>由于浮动元素不再占用原文档流的位置，所以它会对后面的元素排版产生影响<br>准确地说，并不是清除浮动，而是清除浮动后造成的影响<br>清除浮动本质清除浮动主要为了解决父级元素因为子级浮动引起内部高度为0 的问题。清除浮动之后， 父级就会根据浮动的子盒子自动检测高度。父级有了高度，就不会影响下面的标准流了</p>
<p>清除浮动的方法<br>选择器 { clear: 属性值; }   clear 清除<br>属性值	描述<br>left	不允许左侧有浮动元素（清除左侧浮动的影响）<br>right	不允许右侧有浮动元素（清除右侧浮动的影响）<br>both	同时清除左右两侧浮动的影响<br>实际工作中,几乎只用clear: both</p>
<p>1).额外标签法(隔墙法)</p>
<p>是W3C推荐的做法是通过在浮动元素末尾添加一个空的标签例如 <div style=”clear:both”></div>，或则其他标签br等亦可。</p>
<p>优点：通俗易懂，书写方便<br>缺点：添加许多无意义的标签，结构化较差。<br>2).父级添加overflow属性方法</p>
<p>可以给父级添加： overflow为 hidden| auto| scroll  都可以实现。<br>优点： 代码简洁<br>缺点： 内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素。<br>3).使用after伪元素清除浮动:after 方式为空元素额外标签法的升级版，好处是不用单独加标签了</p>
<pre><code>.clearfix:after &#123;
    content: &quot;&quot;;
    display: block;
    height: 0;
    clear: both;
    visibility: hidden;
&#125;

/* IE6、7 专有 */
.clearfix &#123;
    *zoom: 1;
&#125;
    
</code></pre>
<p>优点：符合闭合浮动思想  结构语义化正确<br>缺点：由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。<br>4).使用双伪元素清除浮动</p>
<pre><code>.clearfix:before,
.clearfix:after &#123;
    content: &quot;&quot;;
    display: table;
&#125;

.clearfix:after &#123;
    clear: both;
&#125;

.clearfix &#123;
   *zoom: 1;
&#125;
</code></pre>
<p>优点： 代码更简洁<br>缺点： 由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。<br>清除浮动总结<br>什么时候用清除浮动呢？</p>
<p>父级没高度<br>子盒子浮动了<br>影响下面布局了，我们就应该清除浮动了。</p>
<p>清除浮动的方式	优点	缺点<br>额外标签法（隔墙法）	通俗易懂，书写方便	添加许多无意义的标签，结构化较差。<br>父级overflow:hidden;	书写简单	溢出隐藏<br>父级after伪元素	结构语义化正确	由于IE6-7不支持:after，兼容性问题<br>父级双伪元素	结构语义化正确	由于IE6-7不支持:after，兼容性问题<br>CSS属性书写顺序<br>建议遵循以下顺序：</p>
<p>布局定位属性：display &#x2F; position &#x2F; float &#x2F; clear &#x2F; visibility &#x2F; overflow（建议 display 第一个写，毕竟关系到模式）</p>
<p>自身属性：width &#x2F; height &#x2F; margin &#x2F; padding &#x2F; border &#x2F; background</p>
<p>文本属性：color &#x2F; font &#x2F; text-decoration &#x2F; text-align &#x2F; vertical-align &#x2F; white- space &#x2F; break-word</p>
<p>其他属性（CSS3）：content &#x2F; cursor &#x2F; border-radius &#x2F; box-shadow &#x2F; text-shadow &#x2F; background:linear-gradient …</p>
<p>.jdc {<br>    display: block;<br>    position: relative;<br>    float: left;<br>    width: 100px;<br>    height: 100px;<br>    margin: 0 10px;<br>    padding: 20px 0;<br>    font-family: Arial, ‘Helvetica Neue’, Helvetica, sans-serif;<br>    color: #333;<br>    background: rgba(0,0,0,.5);<br>    -webkit-border-radius: 10px;<br>    -moz-border-radius: 10px;<br>    -o-border-radius: 10px;<br>    -ms-border-radius: 10px;<br>    border-radius: 10px;<br>}</p>
<p>定位(position)<br>「1. 定位详解」</p>
<p>将盒子「定」在某一个「位」置  自由的漂浮在其他盒子(包括标准流和浮动)的上面。</p>
<p>所以，我们脑海应该有三种布局机制的上下顺序👇👇<br>标准流在最底层 (海底)  ——-    浮动 的盒子 在 中间层  (海面)  ——-   定位的盒子 在 最上层  （天空）</p>
<p>定位是用来布局的，它有两部分组成：定位 &#x3D; 定位模式 + 边偏移在 CSS 中，通过 top、bottom、left 和 right 属性定义元素的「边偏移」：（方位名词）</p>
<p>边偏移属性	示例	描述<br>top	top: 80px	「顶端」偏移量，定义元素相对于其父元素「上边线的距离」。<br>bottom	bottom: 80px	「底部」偏移量，定义元素相对于其父元素「下边线的距离」。<br>left	left: 80px	「左侧」偏移量，定义元素相对于其父元素「左边线的距离」。<br>right	right: 80px	「右侧」偏移量，定义元素相对于其父元素「右边线的距离」<br>图片<br>「2. 定位模式(position)」在 CSS 中，通过 position 属性定义元素的「定位模式」，语法如下：</p>
<p>选择器 { position: 属性值; }<br>值	语义<br>static	「静态」定位<br>relative	「相对」定位<br>absolute	「绝对」定位<br>fixed	「固定」定位<br>「3. 静态定位(static)」</p>
<p>静态定位是元素的默认定位方式，无定位的意思。它相当于border里面的none，不要定位的时候用。<br>静态定位 按照标准流特性摆放位置。它没有边偏移。<br>静态定位在布局时几乎不用<br>「4. 相对定位(relative)」</p>
<p>相对定位是元素相对于它原来在标准流中的位置来说的。图片<br>相对于自己原来在标准流中位置来移动的<br>原来在标准流的区域继续占有，后面的盒子仍然以标准流的方式对待它。<br>「5. 绝对定位(absolute)」</p>
<p>绝对定位是元素以带有定位的父级元素来移动位置</p>
<p>完全脱表–完全不占位置；<br>父元素没有定位，则以浏览器为准定位(Document文档)。<br>图片<br>父元素有定位<br>图片<br>定位口诀–子绝父相<br>「6. 固定定位(fixed)」</p>
<p>固定定位是绝对定位的一种特殊形式;</p>
<p>完全脱标–完全不占位置；<br>只认浏览器的可视窗口–浏览器可视窗口+边偏移属性来设置元素的位置<br>跟父元素没有任何关系；单独使用<br>不随滚动条滚动<br>定位(position)的扩展<br>绝对定位的盒子居中<br>绝对定位&#x2F;固定定位的盒子不能通过设置margin: auto设置水平居中 在使用绝对定位时要向实现水平居中，可以按照下面的方法：</p>
<p>图片<br>left : 50%:让盒子的左侧移动到父级元素的水平中心位置；<br>margin-left: -100px;让盒子向左移动自身宽度的一半。<br>同理垂直居中。<br>堆叠顺序（z-index）<br>在使用「定位」布局时，可能会「出现盒子重叠的情况」。</p>
<p>加了定位的盒子，默认「后来者居上」， 后面的盒子会压住前面的盒子。</p>
<p>应用 z-index 层叠等级属性可以「调整盒子的堆叠顺序」。如下图所示：</p>
<p>图片z-index的特性如下:</p>
<p>属性值：正整数、负整数或 0，默认值是 0，数值越大，盒子越靠上；<br>如果属性值相同，则按照书写顺序，后来居上；<br>数字后面不能加单位<br>z-index只能用于相对定位、绝对定位和固定定位的元素，其他标准流、浮动和静态定位无效。<br>定位改变display属性<br>前面提过， display 是 显示模式， 可以通过以下方式改变显示模式:</p>
<p>可以用inline-block  转换为行内块<br>可以用浮动 float 默认转换为行内块（类似，并不完全一样，因为浮动是脱标的）<br>绝对定位和固定定位也和浮动类似， 默认转换的特性 转换为行内块。<br>所以说， 一个行内的盒子，如果加了「浮动」、「固定定位」和「绝对定位」，不用转换，就可以给这个盒子直接设置宽度和高度等。</p>
<p>定位小结<br>定位模式	是否脱标占有位置	移动位置基准	模式转换（行内块）	使用情况<br>静态static	不脱标，正常模式	正常模式	不能	几乎不用<br>相对定位relative	不脱标，占有位置	相对自身位置移动	不能	基本单独使用<br>绝对定位absolute	完全脱标，不占有位置	相对于定位父级移动位置	能	要和定位父级元素搭配使用<br>固定定位fixed	完全脱标，不占有位置	相对于浏览器移动位置	能	单独使用，不需要父级<br>注意：</p>
<p>边偏移 需要和 定位模式 联合使用，单独使用无效；<br>top 和 bottom 不要同时使用；<br>left 和 right 不要同时使用。</p>
<p>CSS高级技巧<br>元素的显示与隐藏<br>目的:让一个元素在页面中消失或者显示出来</p>
<p>场景:类似网站广告，当我们点击关闭就不见了，但是我们重新刷新页面，会重新出现！</p>
<p>1.1 display 显示（重点）<br>display设置或检索对象是否显示或如何显示。</p>
<p>display: none 隐藏对象<br>特点：隐藏之后，不再保留位置。<br>display: block 除了转换为块级元素之外，同时还有显示元素的意思。<br>图片实际开发场景：配合后面js做特效，比如下拉菜单，原先没有，鼠标经过，显示下拉菜单， 应用极为广泛</p>
<p>1.2 visibility 可见性<br>设置或检索是否显示对象</p>
<p>visibility：visible ;  对象可视</p>
<p>visibility：hidden;    对象隐藏<br>特点：隐藏之后，继续保留原有位置。<br>图片<br>1.3 overflow 溢出<br>检索或设置当对象的内容超过其指定高度及宽度时如何管理内容。</p>
<p>属性值	描述<br>visible	不剪切内容也不添加滚动条<br>hidden	不显示超过对象尺寸的内容，超出的部分隐藏掉<br>scroll	不管超出内容否，总是显示滚动条<br>auto	超出自动显示滚动条，不超出不显示滚动条<br>图片实际开发场景：</p>
<p>清除浮动<br>隐藏超出内容，隐藏掉,  不允许内容超过父盒子。<br>1.4 显示与隐藏总结<br>属性	区别	用途<br>display	隐藏对象，不保留位置	配合后面js做特效，比如下拉菜单，原先没有，鼠标经过，显示下拉菜单， 应用极为广泛<br>visibility	隐藏对象，保留位置	使用较少<br>overflow	只是隐藏超出大小的部分	1. 可以清除浮动 2. 保证盒子里面的内容不会超出该盒子范围<br>CSS用户界面样式<br>所谓的界面样式， 就是更改一些用户操作样式，以便提高更好的用户体验。</p>
<p>更改用户的鼠标样式<br>表单轮廓等。<br>防止表单域拖拽<br>2.1 鼠标样式<br>设置或检索在对象上移动的鼠标指针采用何种系统预定义的光标形状。</p>
<p>属性值	描述<br>default	小白  默认<br>pointer	小手<br>move	移动<br>text	文本<br>not-allowed	禁止</p>
<ul>
  <li style="cursor:default">我是小白</li>
  <li style="cursor:pointer">我是小手</li>
  <li style="cursor:move">我是移动</li>
  <li style="cursor:text">我是文本</li>
  <li style="cursor:not-allowed">我是文本</li>
</ul>
2.2 轮廓线 outline
图片是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。

<p>outline : outline-color ||outline-style || outline-width<br>但是我们都不关心可以设置多少，我们平时都是去掉的。<br>最直接的写法是 ： outline: 0;   或者   outline: none;</p>
<p>2.3 防止拖拽文本域resize<br>图片</p>
<textarea  style="resize: none;"></textarea>
<p>2.4 用户界面样式总结<br>属性	用途	用途<br>鼠标样式	更改鼠标样式cursor	样式很多，重点记住 pointer<br>轮廓线	表单默认outline	outline 轮廓线，我们一般直接去掉，border是边框，我们会经常用<br>防止拖拽	主要针对文本域resize	防止用户随意拖拽文本域，造成页面布局混乱，我们resize:none<br>vertical-align 垂直对齐<br>有宽度的块级元素居中对齐，是margin: 0 auto;<br>让文字居中对齐，是 text-align: center;<br>vertical-align 垂直对齐，它只针对于「行内元素」或者「行内块元素」</p>
<p>图片<br>设置或检索对象内容的垂直对其方式。<br>vertical-align : baseline |top |middle |bottom<br>注意：</p>
<p>vertical-align 不影响块级元素中的内容对齐，它只针对于「行内元素」或者「行内块元素」，</p>
<p>特别是行内块元素， 通常用来控制图片&#x2F;表单与文字的对齐。</p>
<p>3.1 图片、表单和文字对齐<br>我们可以通过vertical-align 控制图片和文字的垂直关系了。默认的图片会和文字基线对齐。</p>
<p>图片<br>图片<br>3.2 去除图片底侧空白缝隙<br>图片原因：图片或者表单等行内块元素，他的底线会和父级盒子的基线对齐。</p>
<p>就是图片底侧会有一个空白缝隙。</p>
<p>解决方法：</p>
<p>给img vertical-align:middle | top| bottom等等。 让图片不要和基线对齐。<br>图片<br>给img 添加 display：block; 转换为块级元素就不会存在问题了。<br>溢出的文字省略号显示<br>4.1 white-space<br>white-space设置或检索对象内文本显示方式。通常我们使用于强制一行显示内容<br>white-space:normal ；默认处理方式</p>
<p>white-space:nowrap ； 强制在同一行内显示所有文本，直到文本结束或者遭遇br标签对象才换行。<br>4.2 text-overflow 文字溢出<br>设置或检索是否使用一个省略标记（…）标示对象内文本的溢出<br>text-overflow : clip ；不显示省略标记（…），而是简单的裁切 </p>
<p>text-overflow：ellipsis ； 当对象内文本溢出时显示省略标记（…）<br>「注意」：</p>
<p>一定要首先强制一行内显示，再次和overflow属性  搭配使用</p>
<p>图片<br>4.3 总结三步曲<br>  &#x2F;<em>1. 先强制一行内显示文本</em>&#x2F;<br>      white-space: nowrap;<br>  &#x2F;<em>2. 超出的部分隐藏</em>&#x2F;<br>      overflow: hidden;<br>  &#x2F;<em>3. 文字用省略号替代超出的部分</em>&#x2F;<br>      text-overflow: ellipsis;<br>CSS精灵技术（sprite)<br>CSS精灵技术（也称CSS Sprites、CSS雪碧）。图片</p>
<p>图所示为网页的请求原理图，当用户访问一个网站时，需要向服务器发送请求，网页上的每张图像都要经过一次请求才能展现给用户。<br>然而，一个网页中往往会应用很多小的背景图像作为修饰，当网页中的图像过多时，服务器就会频繁地接受和发送请求，这将大大降低页面的加载速度。<br>为什么需要精灵技术：为了有效地减少服务器接受和发送请求的次数，提高页面的加载速度。</p>
<p>5.1 精灵技术讲解<br>CSS 精灵其实是将网页中的一些背景图像整合到一张大图中（精灵图），然而，各个网页元素通常只需要精灵图中不同位置的某个小图，要想精确定位到精灵图中的某个小图。</p>
<p>图片这样，当用户访问该页面时，只需向服务发送一次请求，网页中的背景图像即可全部展示出来。</p>
<p>我们需要使用CSS的:</p>
<p>background-image、<br>background-repeat<br>background-position属性进行背景定位，<br>其中最关键的是使用background-position 属性精确地定位。<br>5.2 精灵技术使用的核心总结<br>首先我们知道，css精灵技术主要针对于背景图片，插入的图片img 是不需要这个技术的。</p>
<p>精确测量，每个小背景图片的大小和 位置。<br>给盒子指定小背景图片时， 背景定位基本都是 负值。<br>滑动门<br>图片<br>6.1 滑动门出现的背景<br>制作网页时，为了美观，常常需要为网页元素设置特殊形状的背景，比如微信导航栏，有凸起和凹下去的感觉，最大的问题是里面的字数不一样多，咋办？</p>
<p>图片为了使各种特殊形状的背景能够自适应元素中文本内容的多少，出现了CSS滑动门技术。它从新的角度构建页面，使各种特殊形状的背景能够自由拉伸滑动，以适应元素内部的文本内容，可用性更强。最常见于各种导航栏的滑动门。</p>
<p>6.2 核心技术<br>核心技术就是利用CSS精灵（主要是背景位置）和 盒子padding撑开宽度, 以便能适应不同字数的导航栏。</p>
<p>一般的经典布局都是这样的：</p>
<li>
  <a href="#">
    <span>导航栏内容</span>
  </a>
</li>
* {
    padding:0;
    margin:0;

<p>   }<br>    body{<br>      background: url(images&#x2F;wx.jpg) repeat-x;<br>    }<br>    .father {<br>      padding-top:20px;<br>    }<br>    li {<br>      padding-left: 16px;<br>      height: 33px;<br>      float: left;<br>      line-height: 33px;<br>      margin:0  10px;<br>      background: url(.&#x2F;images&#x2F;to.png) no-repeat left ;<br>    }<br>    a {<br>      padding-right: 16px;<br>      height: 33px;<br>      display: inline-block;<br>      color:#fff;<br>      background: url(.&#x2F;images&#x2F;to.png) no-repeat right ;<br>      text-decoration: none;<br>    }<br>    li:hover,<br>    li:hover a {<br>      background-image:url(.&#x2F;images&#x2F;ao.png);<br>    }<br>总结：</p>
<p>a 设置 背景左侧，padding撑开合适宽度。<br>span 设置背景右侧， padding撑开合适宽度 剩下由文字继续撑开宽度。<br>之所以a包含span就是因为 整个导航都是可以点击的。<br>CSS 三角形<br>div {</p>
<pre><code>width: 0; 

height: 0;
line-height:0；
font-size: 0;
</code></pre>
<p>   border-top: 10px solid red;</p>
<p>   border-right: 10px solid green;</p>
<p>   border-bottom: 10px solid blue;</p>
<p>   border-left: 10px solid #000; </p>
<pre><code> &#125;
</code></pre>
<p>图片<br>我们用css 边框可以模拟三角效果<br>宽度高度为0<br>我们4个边框都要写， 只保留需要的边框颜色，其余的不能省略，都改为 transparent 透明就好了<br>为了照顾兼容性 低版本的浏览器，加上 font-size: 0;  line-height: 0;</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Sterling</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/04/03/css%E5%9F%BA%E7%A1%80/">http://example.com/2022/04/03/css%E5%9F%BA%E7%A1%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">lzh-zone</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2022/03/28/zXHY3nC2V7vguRT.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/04/14/%E8%A7%86%E9%A2%91%E8%A7%A3%E6%9E%90/" title="「油猴脚本」各大网页VIP视频解析（截止4.14稳定运行）"><img class="cover" src="https://s2.loli.net/2022/03/28/zXHY3nC2V7vguRT.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">「油猴脚本」各大网页VIP视频解析（截止4.14稳定运行）</div></div></a></div><div class="next-post pull-right"><a href="/2022/04/03/html%E7%AC%94%E8%AE%B0/" title="「学习笔记」HTML基础"><img class="cover" src="https://s2.loli.net/2022/03/28/zXHY3nC2V7vguRT.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">「学习笔记」HTML基础</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><div class="author-info__sayhi" id="author-info__sayhi">大家好！我是</div><div class="author-info__name">林子皓Sterling</div><div class="author-info__description">这有关于<b>日常、问题、技巧</b>相关的问题和看法，还有<b>影视cms开发</b>和<b>音乐交流</b>。</div><div class="author-info__description2">相信你可以在这里找到对你有用的<b>知识</b>和<b>教程</b>。</div></div></div><div class="banner-button-group"><a class="banner-button" onclick="pjax.loadUrl(&quot;/about/&quot;)" data-pjax-state="data-pjax-state"><i class="fas fa-circle-chevron-right"></i><span class="banner-button-text">了解更多</span></a></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener external nofollow" href="https://github.com/lzh-zone"><i class="fab fa-github"></i><span>Github</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://sterling.cf" rel="external nofollow" target="_blank" title="video"><i class="ri-dribbble-line"></i></a><a class="social-icon" href="https://github.com/lzh-zone" rel="external nofollow" target="_blank" title="Github"><i class="ri-github-line"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">永远学不会敲代码呀！</div></div><div class="card-widget" id="card-poem"><div id="poem_sentence"></div><div id="poem_info"><div id="poem_dynasty"></div><div id="poem_author"></div></div></div><script src="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/poem/jinrishici.js" charset="utf-8"></script><script type="text/javascript">jinrishici.load(function(result) {
var sentence = document.querySelector("#poem_sentence")
var author = document.querySelector("#poem_author")
var dynasty = document.querySelector("#poem_dynasty")

var sentenceText = result.data.content
sentenceText = sentenceText.substr(0, sentenceText.length - 1);
sentence.innerHTML = sentenceText
dynasty.innerHTML = result.data.origin.dynasty
author.innerHTML = result.data.origin.author + '《' + result.data.origin.title + '》'
});</script><div class="card-widget card-zhihu"><div class="card-content"><div class="item-headline"><i class="fab fa-deviantart"></i><span>知乎热榜</span></div><div id="zhihu-container"><div class="zhihu-list"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">***、、、、、等，其中标签是最典型的块元素。
块级元素的特点独占一行高度，宽度，外边距以及内边距都可以控制。宽度默认是容器(父级宽度)的100%是一个容器及盒子，里面可以放行内或者块级元素注意：只有文字才能组成段落，因此p标签里面不能放块级元素，特别是p不能放div。同理，还有h1~h6，dt,它们都是文字类块级标签，里面不能放其他块级元素。「2. 行内元素(inline-level)」
有的地方也称为内联元素
常见的行内元素有&#x2F;*、、、、、、、、、#等，其中标签最典型的行内元素。
行内元素的特点相邻行内元素在一行上，一行可以显示多个。高度、宽度直接设置是无效的。默认高度就是它本身内容的宽度。行内元素只能容纳文本或其他行内元素。注意链接里面不能再放链接特殊情况a里面可以放块级元素，但是给a转换一下块级模式最安全。「3. 行内块元素(inline-block)」
在行内元素中有几个特殊的标签——、、，可以对它们设置宽高和对齐属性，有些资料可能会称它们为行内块元素。
行内块元素的特点和相邻行内元素(行内块)在一行上，但是之间会有空白风险。一行可以显示多个默认宽度就是它本身内容的宽度。高度，行高，外边距以及内边距都可以控制。三种模式总结元素模式	元素排列	设置样式	默认宽度	包含块级元素	一行只能放一个块级元素	可以设置宽度高度	容器的100%	容器级可以包含任何标签行内元素	一行可以放多个行内元素	不可以直接设置宽度高度	它本身内容的宽度	容纳文本或则其他行内元素行内块元素	一行放多个行内块元素	可以设置宽度和高度	它本身内容的宽度	
CSS背景(background)「1. 背景颜色」
background-color: 颜色值;   默认的值是 transparent  透明的「2. 背景图片(image)」
语法：background-image : none | url (url) ;例如:background-image: url(images&#x2F;1.png);「3. 背景平铺（repeat）」
background-repeat : repeat | no-repeat | repeat-x | repeat-y参数	作用repeat	背景图像在纵向和横向上平铺（默认的）no-repeat	背景图像不平铺repeat-x	背景图像在横向上平铺repeat-y	背景图像在纵向平铺「4. 背景位置(position)」
background-position : length || lengthbackground-position : position || position参数	值length	百分数 | 由浮点数字和单位标识符组成的长度值position	top | center | bottom | left | center | right   方位名词注意：必须先指定background-image属性position 后面是x坐标和y坐标。可以使用方位名词或者 精确单位。如果指定两个值，两个值都是方位名字，则两个值前后顺序无关，比如left  top和top  left效果一致如果只指定了一个方位名词，另一个值默认居中对齐。如果position 后面是精确坐标， 那么第一个，肯定是 x 第二个一定是y如果只指定一个数值,那该数值一定是x坐标，另一个默认垂直居中如果指定的两个值是 精确单位和方位名字混合使用，则第一个值是x坐标，第二个值是y坐标背景简写：background：属性的值的书写顺序官方没有强制的标准。为了可读性，建议如下写：background: 背景颜色 背景图片地址 背景平铺 背景滚动 背景位置;&#x2F;* 有背景图片背景颜色可以不用写*&#x2F;background: transparent url(image.jpg) repeat-y  scroll center top ;「5. 背景半透明(CSS3)」
background: rgba(0, 0, 0, 0.3);background: rgba(0, 0, 0, .3);等同于background-color: rgba(0, 0, 0, .3)最后一个参数是alpha 透明度  取值范围 0~1之间我们习惯把0.3 的 0 省略掉  这样写 background: rgba(0, 0, 0, .3);注意：背景半透明是指盒子背景半透明，盒子里面的内容不受影响低于IE 9的版本不支持盒子半透明 opacity设置opacity元素的所有后代元素会随着一起具有透明性，一般用于调整图片或者模块的整体不透明度opacity: .2;「6. 背景总结」
属性	作用	值background-color	背景颜色	预定义的颜色值&#x2F;十六进制&#x2F;RGB代码background-image	背景图片	url(图片路径)background-repeat	是否平铺	repeat&#x2F;no-repeat&#x2F;repeat-x&#x2F;repeat-ybackground-position	背景位置	length&#x2F;position    分别是x  和 y坐标， 切记 如果有 精确数值单位，则必须按照先X 后Y 的写法background-attachment	背景固定还是滚动	scroll&#x2F;fixed背景简写	更简单	背景颜色 背景图片地址 背景平铺 背景滚动 背景位置;  他们没有顺序背景透明	让盒子半透明	background: rgba(0,0,0,0.3);   后面必须是 4个值
CSS三大特性「1. CSS 层叠性」
图片-概念：
所谓层叠性是指多种CSS样式的叠加是浏览器处理冲突的一个能力,如果一个属性通过两个相同选择器设置到同一个元素上，那么这个时候一个属性就会将另一个属性层叠掉-原则：
样式冲突，遵循的原则是就近原则。 那个样式离着结构近，就执行那个样式。样式不冲突，不会层叠。「2. CSS 继承性」
图片-概念：
子标签会继承父标签的某些样式，如文本颜色和字号。想要设置一个可继承的属性，只需将它应用于父元素即可。-注意：
恰当地使用继承可以简化代码，降低CSS样式的复杂性。比如有很多子级孩子都需要某个样式，可以给父级指定一个，这些孩子继承过来就好了。子元素可以继承父元素的样式（text-，font-，line-这些元素开头的可以继承，以及color属性）「3. CSS 优先级(CSS特殊性)」
图片-概念：定义CSS样式时，经常出现两个或更多规则应用在同一元素上，此时，
选择器相同，则执行层叠性选择器不同，就会出现优先级的问题。-权重计算公式：
标签选择器	计算权重公式继承或者 *	0,0,0,0每个元素（标签选择器）	0,0,0,1每个类，伪类	0,0,1,0每个ID	0,1,0,0每个行内样式 style&#x3D;””	1,0,0,0每个!important  最重要的	∞ 无穷大值从左到右，左面的最大，一级大于一级，数位之间没有进制，级别之间不可超越。关于CSS权重，我们需要一套计算公式来去计算，这个就是 CSS Specificity（特殊性）div { color: pink !important; }-权重叠加：
 div ul  li   ——&gt;      0,0,0,3 .nav ul li   ——&gt;      0,0,1,2 a:hover      —–—&gt;      0,0,1,1 .nav a       ——&gt;      0,0,1,1-继承的权重是0：
我们修改样式，一定要看该标签有没有被选中如果选中了，那么以上面的公式来计权重。谁大听谁的。如果没有选中，那么权重是0，因为继承的权重为0.
盒子模型css学习三大重点： css 盒子模型 、 浮动 、 定位  
网页布局的本质
首先利用CSS设置好盒子的大小，然后摆放盒子的位置。最后把网页元素比如文字图片等等，放入盒子里面。

盒子模型(Box Model)盒子模型就是把HTML页面中的布局元素看作是一个矩形的盒子，也就是一个盛装内容的容器。盒子模型由元素的内容、边框（border）、内边距（padding）、和外边距（margin）组成。盒子里面的文字和图片等元素是 内容区域盒子的厚度 我们称为为盒子的边框盒子内容与边框的距离是内边距盒子与盒子之间的距离是外边距W3c标准盒子模型

标准 w3c 盒子模型的范围包括 margin、border、padding、content
当设置为box-sizing: content-box;时，将采用标准模式解析计算，也是默认模式；
内盒尺寸计算(元素实际大小)
宽度：Element Height &#x3D; content height + padding + border （Height为内容高度）高度：Element  Width &#x3D; content width + padding + border （Width为内容宽度）盒子的实际大小：内容的宽度和高度 +  内边距   +  边框  图片IE盒子模型IE 盒子模型的 content 部分包含了 border 和 pading
当设置为box-sizing: border-box时，将采用怪异模式解析计算；

盒子边框(border)属性	作用border-width	定义边框粗细，单位是pxborder-style	边框的样式border-color	边框颜色边框的样式：

none：没有边框即忽略所有边框的宽度（默认值）solid：边框为单实线(最为常用的)dashed：边框为虚线dotted：边框为点线边框综合设置border : border-width || border-style || border-color 
border: 1px solid red;  没有顺序要求盒子边框写法总结表：
很多情况下，我们不需要指定4个边框，我们是可以单独给4个边框分别指定的。
上边框	下边框	左边框	右边框border-top-style:样式;	border-bottom-style:样式;	border-left-style:样式;	border-right-style:样式;border-top-width:宽度;	border- bottom-width:宽度;	border-left-width:宽度;	border-right-width:宽度;border-top-color:颜色;	border- bottom-color:颜色;	border-left-color:颜色;	border-right-color:颜色;border-top:宽度 样式 颜色;	border-bottom:宽度 样式 颜色;	border-left:宽度 样式 颜色;	border-right:宽度 样式 颜色;表格的细线边框：
图片通过表格的cellspacing&#x3D;”0”,将单元格与单元格之间的距离设置为0，但是两个单元格之间的边框会出现重叠，从而使边框变粗通过css属性：table{ border-collapse:collapse; }collapse 单词是合并的意思,border-collapse: collapse;表示相邻边框合并在一起。

 table {
  width: 500px;
  height: 300px;
  border: 1px solid red;
 }
 td {
  border: 1px solid red;
  text-align: center;
 }
 table, td {
  border-collapse: collapse;  &#x2F;*合并相邻边框*&#x2F;
 }


内边距(padding)padding属性用于设置内边距。是指边框与内容之间的距离。

设置
属性	作用padding-left	左内边距padding-right	右内边距padding-top	上内边距padding-bottom	下内边距padding简写
值的个数	表达意思1个值	padding：上下左右内边距;2个值	padding: 上下内边距    左右内边距 ；3个值	padding：上内边距   左右内边距   下内边距；4个值	padding: 上内边距 右内边距 下内边距 左内边距 ；当我们给盒子指定padding值之后， 发生了2件事情：
内容和边框 有了距离，添加了内边距。盒子会变大解决措施：通过给设置了宽高的盒子，减去相应的内边距的值，维持盒子原有的大小。
padding不影响盒子大小情况：👉如果没有给一个盒子指定宽度， 此时，如果给这个盒子指定padding， 则不会撑开盒子。

外边距（margin）margin属性用于设置外边距。margin就是控制盒子和盒子之间的距离

设置
属性	作用margin-left	左外边距margin-right	右外边距margin-top	上外边距margin-bottom	下外边距margin值的简写 （复合写法）代表意思  跟 padding 完全相同。
块级盒子水平居中
盒子必须指定宽度（width）然后就给左右的外边距都设置为auto实际工作中常用这种方式进行网页布局，示例代码如下：
.header  { width: 960px; margin: 0 auto;}常见的写法，以下下三种都可以👇👇。
margin-left: auto;   margin-right: auto;margin: auto;margin: 0 auto;文字居中和盒子居中区别👇👇
盒子内的文字水平居中是 text-align: center; 而且还可以让 行内元素和行内块居中对齐块级盒子水平居中  左右margin 改为 auto插入图片和背景图片区别👇👇
插入图片我们用的最多 比如产品展示类  移动位置只能靠盒模型 padding margin背景图片我们一般用于小图标背景或者超大背景图片、背景图片，移动位置只能通过  background-position清除元素的默认内外边距👇👇
行内元素为了照顾兼容性,尽量只设置左右内外边距，不要设置上下内外边距。

{ padding:0;         &#x2F;* 清除内边距 &#x2F; margin:0;          &#x2F; 清除外边距 *&#x2F;}4.外边距合并使用margin定义块元素的「垂直外边距」时，可能会出现外边距的合并。

(1). 相邻块元素垂直外边距的合并当上下相邻的两个块元素相遇时，如果上面的元素有下外边距margin-bottom下面的元素有上外边距margin-top，则他们之间的垂直间距不是margin-bottom与margin-top之和「取两个值中的较大者」这种现象被称为相邻块元素垂直外边距的合并（也称外边距塌陷）。图片「解决方案：尽量给只给一个盒子添加margin值」。
(2). 嵌套块元素垂直外边距的合并（塌陷）对于两个嵌套关系的块元素，如果父元素没有上内边距及边框父元素的上外边距会与子元素的上外边距发生合并合并后的外边距为两者中的较大者图片「解决方案：」
可以为父元素定义上边框。可以为父元素定义上内边距可以为父元素添加overflow: hidden。还有其他方法，比如浮动、固定、绝对定位的盒子不会有问题，后面咱们再总结。。。
盒子模型布局稳定性优先使用  宽度 （width）  其次 使用内边距（padding）    再次  外边距（margin）
width &gt;  padding  &gt;   margin原因：
margin 会有外边距合并 还有 ie6下面margin 加倍的bug（讨厌）所以最后使用。padding  会影响盒子大小， 需要进行加减计算（麻烦） 其次使用。width   没有问题（嗨皮）我们经常使用宽度剩余法 高度剩余法来做。5. CSS3 新增圆角边框：
border-radius:length;
border-top-left-radius   定义了左上角的弧度border-top-right-radius   定义了右上角的弧度border-bottom-right-radius   定义了右下角的弧度border-bottom-left-radius   定义了左下角的弧度其中每一个值可以为 数值或百分比的形式。技巧：让一个正方形 变成圆圈border-radius: 50%;图片如果要在四个角上一一指定，可以使用以下规则👇👇：
border-radius: 左上角 右上角  右下角  左下角;四个值: 第一个值为左上角，第二个值为右上角，第三个值为右下角，第四个值为左下角。三个值: 第一个值为左上角, 第二个值为右上角和左下角，第三个值为右下角两个值: 第一个值为左上角与右下角，第二个值为右上角与左下角一个值：四个圆角值相同盒子阴影(box-shadow)：
box-shadow: offset-x offset-y [blur [spread]] [color] [inset]值	描述offset-x	阴影的水平偏移量。正数向右偏移，负数向左偏移。offset-y	阴影的垂直偏移量。正数向下偏移，负数向上偏移。blur	可选。阴影模糊距离，不能取负数。spread	可选。阴影大小color	可选。阴影的颜色inset	可选。表示添加内阴影，默认为外阴影div {   width: 200px;   height: 200px;   border: 10px solid red;   &#x2F;* box-shadow: 5px 5px 3px 4px rgba(0, 0, 0, .4);  &#x2F;   &#x2F; box-shadow:水平位置 垂直位置 模糊距离 阴影尺寸（影子大小） 阴影颜色  内&#x2F;外阴影； *&#x2F;   box-shadow: 0 15px 30px  rgba(0, 0, 0, .4);}
浮动浮动「1. CSS布局的三种机制」
网页布局的核心——就是用CSS来摆放盒子。
CSS 提供了3种机制来设置盒子的摆放位置，分别是普通流（标准流）、浮动和定位，其中：
A. 普通流（标准流）
块级元素会独占一行，从上向下顺序排列；常用元素：div、hr、p、h1~h6、ul、ol、dl、form、table行内元素会按照顺序，从左到右顺序排列，碰到父元素边缘则自动换行；常用元素：span、a、i、em等B. 浮动
让盒子从普通流中浮起来,主要作用让多个块级盒子一行显示。C. 定位
将盒子定在浏览器的某一个位置——CSS 离不开定位，特别是后面的 js 特效。「2. 什么是浮动」元素的浮动是指设置了浮动属性的元素会
脱离标准普通流的控制,不占位置，脱标移动到指定位置。作用让多个盒子(div)水平排列成一行，使得浮动称为布局的重要手段。可以实现盒子的左右对齐等等。浮动最早是用来控制图片，实现文字环绕图片效果。float属性会改变元素的display属性，任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。生成的块级框和我们前面的行内块极其相似。语法选择器 { float: 属性值; }属性值	描述none	元素不浮动（默认值）left	元素向左浮动right	元素向右浮动
浮动只会影响当前的或者是后面的标准流盒子，不会影响前面的标准流。建议:如果一个盒子里面有多个子盒子，如果其中一个盒子浮动了，其他兄弟也应该浮动。防止引起问题
图片浮动(float)小结
特点	说明浮	加了浮动的盒子「是浮起来」的，漂浮在其他标准流盒子的上面。漏	加了浮动的盒子「是不占位置的」，它原来的位置「漏给了标准流的盒子」。特	「特别注意」：浮动元素会改变display属性， 类似转换为了行内块，但是元素之间没有空白缝隙清除浮动因为父级盒子很多情况下，不方便给高度，但是子盒子浮动就不占有位置，最后父级盒子高度为0，就影响了下面的标准流盒子。图片图片总结：
由于浮动元素不再占用原文档流的位置，所以它会对后面的元素排版产生影响准确地说，并不是清除浮动，而是清除浮动后造成的影响清除浮动本质清除浮动主要为了解决父级元素因为子级浮动引起内部高度为0 的问题。清除浮动之后， 父级就会根据浮动的子盒子自动检测高度。父级有了高度，就不会影响下面的标准流了
清除浮动的方法选择器 { clear: 属性值; }   clear 清除属性值	描述left	不允许左侧有浮动元素（清除左侧浮动的影响）right	不允许右侧有浮动元素（清除右侧浮动的影响）both	同时清除左右两侧浮动的影响实际工作中,几乎只用clear: both
1).额外标签法(隔墙法)
是W3C推荐的做法是通过在浮动元素末尾添加一个空的标签例如 ，或则其他标签br等亦可。
优点：通俗易懂，书写方便缺点：添加许多无意义的标签，结构化较差。2).父级添加overflow属性方法
可以给父级添加： overflow为 hidden| auto| scroll  都可以实现。优点： 代码简洁缺点： 内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素。3).使用after伪元素清除浮动:after 方式为空元素额外标签法的升级版，好处是不用单独加标签了
.clearfix:after {
    content: &quot;&quot;;
    display: block;
    height: 0;
    clear: both;
    visibility: hidden;
}

&#x2F;* IE6、7 专有 *&#x2F;
.clearfix {
    *zoom: 1;
}
    

优点：符合闭合浮动思想  结构语义化正确缺点：由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。4).使用双伪元素清除浮动
.clearfix:before,
.clearfix:after {
    content: &quot;&quot;;
    display: table;
}

.clearfix:after {
    clear: both;
}

.clearfix {
   *zoom: 1;
}

优点： 代码更简洁缺点： 由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。清除浮动总结什么时候用清除浮动呢？
父级没高度子盒子浮动了影响下面布局了，我们就应该清除浮动了。
清除浮动的方式	优点	缺点额外标签法（隔墙法）	通俗易懂，书写方便	添加许多无意义的标签，结构化较差。父级overflow:hidden;	书写简单	溢出隐藏父级after伪元素	结构语义化正确	由于IE6-7不支持:after，兼容性问题父级双伪元素	结构语义化正确	由于IE6-7不支持:after，兼容性问题CSS属性书写顺序建议遵循以下顺序：
布局定位属性：display &#x2F; position &#x2F; float &#x2F; clear &#x2F; visibility &#x2F; overflow（建议 display 第一个写，毕竟关系到模式）
自身属性：width &#x2F; height &#x2F; margin &#x2F; padding &#x2F; border &#x2F; background
文本属性：color &#x2F; font &#x2F; text-decoration &#x2F; text-align &#x2F; vertical-align &#x2F; white- space &#x2F; break-word
其他属性（CSS3）：content &#x2F; cursor &#x2F; border-radius &#x2F; box-shadow &#x2F; text-shadow &#x2F; background:linear-gradient …
.jdc {    display: block;    position: relative;    float: left;    width: 100px;    height: 100px;    margin: 0 10px;    padding: 20px 0;    font-family: Arial, ‘Helvetica Neue’, Helvetica, sans-serif;    color: #333;    background: rgba(0,0,0,.5);    -webkit-border-radius: 10px;    -moz-border-radius: 10px;    -o-border-radius: 10px;    -ms-border-radius: 10px;    border-radius: 10px;}
定位(position)「1. 定位详解」
将盒子「定」在某一个「位」置  自由的漂浮在其他盒子(包括标准流和浮动)的上面。
所以，我们脑海应该有三种布局机制的上下顺序👇👇标准流在最底层 (海底)  ——-    浮动 的盒子 在 中间层  (海面)  ——-   定位的盒子 在 最上层  （天空）
定位是用来布局的，它有两部分组成：定位 &#x3D; 定位模式 + 边偏移在 CSS 中，通过 top、bottom、left 和 right 属性定义元素的「边偏移」：（方位名词）
边偏移属性	示例	描述top	top: 80px	「顶端」偏移量，定义元素相对于其父元素「上边线的距离」。bottom	bottom: 80px	「底部」偏移量，定义元素相对于其父元素「下边线的距离」。left	left: 80px	「左侧」偏移量，定义元素相对于其父元素「左边线的距离」。right	right: 80px	「右侧」偏移量，定义元素相对于其父元素「右边线的距离」图片「2. 定位模式(position)」在 CSS 中，通过 position 属性定义元素的「定位模式」，语法如下：
选择器 { position: 属性值; }值	语义static	「静态」定位relative	「相对」定位absolute	「绝对」定位fixed	「固定」定位「3. 静态定位(static)」
静态定位是元素的默认定位方式，无定位的意思。它相当于border里面的none，不要定位的时候用。静态定位 按照标准流特性摆放位置。它没有边偏移。静态定位在布局时几乎不用「4. 相对定位(relative)」
相对定位是元素相对于它原来在标准流中的位置来说的。图片相对于自己原来在标准流中位置来移动的原来在标准流的区域继续占有，后面的盒子仍然以标准流的方式对待它。「5. 绝对定位(absolute)」
绝对定位是元素以带有定位的父级元素来移动位置
完全脱表–完全不占位置；父元素没有定位，则以浏览器为准定位(Document文档)。图片父元素有定位图片定位口诀–子绝父相「6. 固定定位(fixed)」
固定定位是绝对定位的一种特殊形式;
完全脱标–完全不占位置；只认浏览器的可视窗口–浏览器可视窗口+边偏移属性来设置元素的位置跟父元素没有任何关系；单独使用不随滚动条滚动定位(position)的扩展绝对定位的盒子居中绝对定位&#x2F;固定定位的盒子不能通过设置margin: auto设置水平居中 在使用绝对定位时要向实现水平居中，可以按照下面的方法：
图片left : 50%:让盒子的左侧移动到父级元素的水平中心位置；margin-left: -100px;让盒子向左移动自身宽度的一半。同理垂直居中。堆叠顺序（z-index）在使用「定位」布局时，可能会「出现盒子重叠的情况」。
加了定位的盒子，默认「后来者居上」， 后面的盒子会压住前面的盒子。
应用 z-index 层叠等级属性可以「调整盒子的堆叠顺序」。如下图所示：
图片z-index的特性如下:
属性值：正整数、负整数或 0，默认值是 0，数值越大，盒子越靠上；如果属性值相同，则按照书写顺序，后来居上；数字后面不能加单位z-index只能用于相对定位、绝对定位和固定定位的元素，其他标准流、浮动和静态定位无效。定位改变display属性前面提过， display 是 显示模式， 可以通过以下方式改变显示模式:
可以用inline-block  转换为行内块可以用浮动 float 默认转换为行内块（类似，并不完全一样，因为浮动是脱标的）绝对定位和固定定位也和浮动类似， 默认转换的特性 转换为行内块。所以说， 一个行内的盒子，如果加了「浮动」、「固定定位」和「绝对定位」，不用转换，就可以给这个盒子直接设置宽度和高度等。
定位小结定位模式	是否脱标占有位置	移动位置基准	模式转换（行内块）	使用情况静态static	不脱标，正常模式	正常模式	不能	几乎不用相对定位relative	不脱标，占有位置	相对自身位置移动	不能	基本单独使用绝对定位absolute	完全脱标，不占有位置	相对于定位父级移动位置	能	要和定位父级元素搭配使用固定定位fixed	完全脱标，不占有位置	相对于浏览器移动位置	能	单独使用，不需要父级注意：
边偏移 需要和 定位模式 联合使用，单独使用无效；top 和 bottom 不要同时使用；left 和 right 不要同时使用。
CSS高级技巧元素的显示与隐藏目的:让一个元素在页面中消失或者显示出来
场景:类似网站广告，当我们点击关闭就不见了，但是我们重新刷新页面，会重新出现！
1.1 display 显示（重点）display设置或检索对象是否显示或如何显示。
display: none 隐藏对象特点：隐藏之后，不再保留位置。display: block 除了转换为块级元素之外，同时还有显示元素的意思。图片实际开发场景：配合后面js做特效，比如下拉菜单，原先没有，鼠标经过，显示下拉菜单， 应用极为广泛
1.2 visibility 可见性设置或检索是否显示对象
visibility：visible ;  对象可视
visibility：hidden;    对象隐藏特点：隐藏之后，继续保留原有位置。图片1.3 overflow 溢出检索或设置当对象的内容超过其指定高度及宽度时如何管理内容。
属性值	描述visible	不剪切内容也不添加滚动条hidden	不显示超过对象尺寸的内容，超出的部分隐藏掉scroll	不管超出内容否，总是显示滚动条auto	超出自动显示滚动条，不超出不显示滚动条图片实际开发场景：
清除浮动隐藏超出内容，隐藏掉,  不允许内容超过父盒子。1.4 显示与隐藏总结属性	区别	用途display	隐藏对象，不保留位置	配合后面js做特效，比如下拉菜单，原先没有，鼠标经过，显示下拉菜单， 应用极为广泛visibility	隐藏对象，保留位置	使用较少overflow	只是隐藏超出大小的部分	1. 可以清除浮动 2. 保证盒子里面的内容不会超出该盒子范围CSS用户界面样式所谓的界面样式， 就是更改一些用户操作样式，以便提高更好的用户体验。
更改用户的鼠标样式表单轮廓等。防止表单域拖拽2.1 鼠标样式设置或检索在对象上移动的鼠标指针采用何种系统预定义的光标形状。
属性值	描述default	小白  默认pointer	小手move	移动text	文本not-allowed	禁止

  我是小白
  我是小手
  我是移动
  我是文本
  我是文本

2.2 轮廓线 outline
图片是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。

outline : outline-color ||outline-style || outline-width但是我们都不关心可以设置多少，我们平时都是去掉的。最直接的写法是 ： outline: 0;   或者   outline: none;
2.3 防止拖拽文本域resize图片

2.4 用户界面样式总结属性	用途	用途鼠标样式	更改鼠标样式cursor	样式很多，重点记住 pointer轮廓线	表单默认outline	outline 轮廓线，我们一般直接去掉，border是边框，我们会经常用防止拖拽	主要针对文本域resize	防止用户随意拖拽文本域，造成页面布局混乱，我们resize:nonevertical-align 垂直对齐有宽度的块级元素居中对齐，是margin: 0 auto;让文字居中对齐，是 text-align: center;vertical-align 垂直对齐，它只针对于「行内元素」或者「行内块元素」
图片设置或检索对象内容的垂直对其方式。vertical-align : baseline |top |middle |bottom注意：
vertical-align 不影响块级元素中的内容对齐，它只针对于「行内元素」或者「行内块元素」，
特别是行内块元素， 通常用来控制图片&#x2F;表单与文字的对齐。
3.1 图片、表单和文字对齐我们可以通过vertical-align 控制图片和文字的垂直关系了。默认的图片会和文字基线对齐。
图片图片3.2 去除图片底侧空白缝隙图片原因：图片或者表单等行内块元素，他的底线会和父级盒子的基线对齐。
就是图片底侧会有一个空白缝隙。
解决方法：
给img vertical-align:middle | top| bottom等等。 让图片不要和基线对齐。图片给img 添加 display：block; 转换为块级元素就不会存在问题了。溢出的文字省略号显示4.1 white-spacewhite-space设置或检索对象内文本显示方式。通常我们使用于强制一行显示内容white-space:normal ；默认处理方式
white-space:nowrap ； 强制在同一行内显示所有文本，直到文本结束或者遭遇br标签对象才换行。4.2 text-overflow 文字溢出设置或检索是否使用一个省略标记（…）标示对象内文本的溢出text-overflow : clip ；不显示省略标记（…），而是简单的裁切 
text-overflow：ellipsis ； 当对象内文本溢出时显示省略标记（…）「注意」：
一定要首先强制一行内显示，再次和overflow属性  搭配使用
图片4.3 总结三步曲  &#x2F;1. 先强制一行内显示文本&#x2F;      white-space: nowrap;  &#x2F;2. 超出的部分隐藏&#x2F;      overflow: hidden;  &#x2F;3. 文字用省略号替代超出的部分&#x2F;      text-overflow: ellipsis;CSS精灵技术（sprite)CSS精灵技术（也称CSS Sprites、CSS雪碧）。图片
图所示为网页的请求原理图，当用户访问一个网站时，需要向服务器发送请求，网页上的每张图像都要经过一次请求才能展现给用户。然而，一个网页中往往会应用很多小的背景图像作为修饰，当网页中的图像过多时，服务器就会频繁地接受和发送请求，这将大大降低页面的加载速度。为什么需要精灵技术：为了有效地减少服务器接受和发送请求的次数，提高页面的加载速度。
5.1 精灵技术讲解CSS 精灵其实是将网页中的一些背景图像整合到一张大图中（精灵图），然而，各个网页元素通常只需要精灵图中不同位置的某个小图，要想精确定位到精灵图中的某个小图。
图片这样，当用户访问该页面时，只需向服务发送一次请求，网页中的背景图像即可全部展示出来。
我们需要使用CSS的:
background-image、background-repeatbackground-position属性进行背景定位，其中最关键的是使用background-position 属性精确地定位。5.2 精灵技术使用的核心总结首先我们知道，css精灵技术主要针对于背景图片，插入的图片img 是不需要这个技术的。
精确测量，每个小背景图片的大小和 位置。给盒子指定小背景图片时， 背景定位基本都是 负值。滑动门图片6.1 滑动门出现的背景制作网页时，为了美观，常常需要为网页元素设置特殊形状的背景，比如微信导航栏，有凸起和凹下去的感觉，最大的问题是里面的字数不一样多，咋办？
图片为了使各种特殊形状的背景能够自适应元素中文本内容的多少，出现了CSS滑动门技术。它从新的角度构建页面，使各种特殊形状的背景能够自由拉伸滑动，以适应元素内部的文本内容，可用性更强。最常见于各种导航栏的滑动门。
6.2 核心技术核心技术就是利用CSS精灵（主要是背景位置）和 盒子padding撑开宽度, 以便能适应不同字数的导航栏。
一般的经典布局都是这样的：

  
    导航栏内容
  

* {
    padding:0;
    margin:0;

   }    body{      background: url(images&#x2F;wx.jpg) repeat-x;    }    .father {      padding-top:20px;    }    li {      padding-left: 16px;      height: 33px;      float: left;      line-height: 33px;      margin:0  10px;      background: url(.&#x2F;images&#x2F;to.png) no-repeat left ;    }    a {      padding-right: 16px;      height: 33px;      display: inline-block;      color:#fff;      background: url(.&#x2F;images&#x2F;to.png) no-repeat right ;      text-decoration: none;    }    li:hover,    li:hover a {      background-image:url(.&#x2F;images&#x2F;ao.png);    }总结：
a 设置 背景左侧，padding撑开合适宽度。span 设置背景右侧， padding撑开合适宽度 剩下由文字继续撑开宽度。之所以a包含span就是因为 整个导航都是可以点击的。CSS 三角形div {
width: 0; 

height: 0;
line-height:0；
font-size: 0;

   border-top: 10px solid red;
   border-right: 10px solid green;
   border-bottom: 10px solid blue;
   border-left: 10px solid #000; 
 }

图片我们用css 边框可以模拟三角效果宽度高度为0我们4个边框都要写， 只保留需要的边框颜色，其余的不能省略，都改为 transparent 透明就好了为了照顾兼容性 低版本的浏览器，加上 font-size: 0;  line-height: 0;
</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link"><span class="toc-number">1.0.0.0.0.1.</span> <span class="toc-text">*、、、、、等，其中标签是最典型的块元素。
块级元素的特点独占一行高度，宽度，外边距以及内边距都可以控制。宽度默认是容器(父级宽度)的100%是一个容器及盒子，里面可以放行内或者块级元素注意：只有文字才能组成段落，因此p标签里面不能放块级元素，特别是p不能放div。同理，还有h1~h6，dt,它们都是文字类块级标签，里面不能放其他块级元素。「2. 行内元素(inline-level)」
有的地方也称为内联元素
常见的行内元素有&#x2F;*、、、、、、、、、#等，其中标签最典型的行内元素。
行内元素的特点相邻行内元素在一行上，一行可以显示多个。高度、宽度直接设置是无效的。默认高度就是它本身内容的宽度。行内元素只能容纳文本或其他行内元素。注意链接里面不能再放链接特殊情况a里面可以放块级元素，但是给a转换一下块级模式最安全。「3. 行内块元素(inline-block)」
在行内元素中有几个特殊的标签——、、，可以对它们设置宽高和对齐属性，有些资料可能会称它们为行内块元素。
行内块元素的特点和相邻行内元素(行内块)在一行上，但是之间会有空白风险。一行可以显示多个默认宽度就是它本身内容的宽度。高度，行高，外边距以及内边距都可以控制。三种模式总结元素模式	元素排列	设置样式	默认宽度	包含块级元素	一行只能放一个块级元素	可以设置宽度高度	容器的100%	容器级可以包含任何标签行内元素	一行可以放多个行内元素	不可以直接设置宽度高度	它本身内容的宽度	容纳文本或则其他行内元素行内块元素	一行放多个行内块元素	可以设置宽度和高度	它本身内容的宽度	
CSS背景(background)「1. 背景颜色」
background-color: 颜色值;   默认的值是 transparent  透明的「2. 背景图片(image)」
语法：background-image : none | url (url) ;例如:background-image: url(images&#x2F;1.png);「3. 背景平铺（repeat）」
background-repeat : repeat | no-repeat | repeat-x | repeat-y参数	作用repeat	背景图像在纵向和横向上平铺（默认的）no-repeat	背景图像不平铺repeat-x	背景图像在横向上平铺repeat-y	背景图像在纵向平铺「4. 背景位置(position)」
background-position : length || lengthbackground-position : position || position参数	值length	百分数 | 由浮点数字和单位标识符组成的长度值position	top | center | bottom | left | center | right   方位名词注意：必须先指定background-image属性position 后面是x坐标和y坐标。可以使用方位名词或者 精确单位。如果指定两个值，两个值都是方位名字，则两个值前后顺序无关，比如left  top和top  left效果一致如果只指定了一个方位名词，另一个值默认居中对齐。如果position 后面是精确坐标， 那么第一个，肯定是 x 第二个一定是y如果只指定一个数值,那该数值一定是x坐标，另一个默认垂直居中如果指定的两个值是 精确单位和方位名字混合使用，则第一个值是x坐标，第二个值是y坐标背景简写：background：属性的值的书写顺序官方没有强制的标准。为了可读性，建议如下写：background: 背景颜色 背景图片地址 背景平铺 背景滚动 背景位置;&#x2F;* 有背景图片背景颜色可以不用写*&#x2F;background: transparent url(image.jpg) repeat-y  scroll center top ;「5. 背景半透明(CSS3)」
background: rgba(0, 0, 0, 0.3);background: rgba(0, 0, 0, .3);等同于background-color: rgba(0, 0, 0, .3)最后一个参数是alpha 透明度  取值范围 0~1之间我们习惯把0.3 的 0 省略掉  这样写 background: rgba(0, 0, 0, .3);注意：背景半透明是指盒子背景半透明，盒子里面的内容不受影响低于IE 9的版本不支持盒子半透明 opacity设置opacity元素的所有后代元素会随着一起具有透明性，一般用于调整图片或者模块的整体不透明度opacity: .2;「6. 背景总结」
属性	作用	值background-color	背景颜色	预定义的颜色值&#x2F;十六进制&#x2F;RGB代码background-image	背景图片	url(图片路径)background-repeat	是否平铺	repeat&#x2F;no-repeat&#x2F;repeat-x&#x2F;repeat-ybackground-position	背景位置	length&#x2F;position    分别是x  和 y坐标， 切记 如果有 精确数值单位，则必须按照先X 后Y 的写法background-attachment	背景固定还是滚动	scroll&#x2F;fixed背景简写	更简单	背景颜色 背景图片地址 背景平铺 背景滚动 背景位置;  他们没有顺序背景透明	让盒子半透明	background: rgba(0,0,0,0.3);   后面必须是 4个值
CSS三大特性「1. CSS 层叠性」
图片-概念：
所谓层叠性是指多种CSS样式的叠加是浏览器处理冲突的一个能力,如果一个属性通过两个相同选择器设置到同一个元素上，那么这个时候一个属性就会将另一个属性层叠掉-原则：
样式冲突，遵循的原则是就近原则。 那个样式离着结构近，就执行那个样式。样式不冲突，不会层叠。「2. CSS 继承性」
图片-概念：
子标签会继承父标签的某些样式，如文本颜色和字号。想要设置一个可继承的属性，只需将它应用于父元素即可。-注意：
恰当地使用继承可以简化代码，降低CSS样式的复杂性。比如有很多子级孩子都需要某个样式，可以给父级指定一个，这些孩子继承过来就好了。子元素可以继承父元素的样式（text-，font-，line-这些元素开头的可以继承，以及color属性）「3. CSS 优先级(CSS特殊性)」
图片-概念：定义CSS样式时，经常出现两个或更多规则应用在同一元素上，此时，
选择器相同，则执行层叠性选择器不同，就会出现优先级的问题。-权重计算公式：
标签选择器	计算权重公式继承或者 *	0,0,0,0每个元素（标签选择器）	0,0,0,1每个类，伪类	0,0,1,0每个ID	0,1,0,0每个行内样式 style&#x3D;””	1,0,0,0每个!important  最重要的	∞ 无穷大值从左到右，左面的最大，一级大于一级，数位之间没有进制，级别之间不可超越。关于CSS权重，我们需要一套计算公式来去计算，这个就是 CSS Specificity（特殊性）div { color: pink !important; }-权重叠加：
 div ul  li   ——&gt;      0,0,0,3 .nav ul li   ——&gt;      0,0,1,2 a:hover      —–—&gt;      0,0,1,1 .nav a       ——&gt;      0,0,1,1-继承的权重是0：
我们修改样式，一定要看该标签有没有被选中如果选中了，那么以上面的公式来计权重。谁大听谁的。如果没有选中，那么权重是0，因为继承的权重为0.
盒子模型css学习三大重点： css 盒子模型 、 浮动 、 定位  
网页布局的本质
首先利用CSS设置好盒子的大小，然后摆放盒子的位置。最后把网页元素比如文字图片等等，放入盒子里面。

盒子模型(Box Model)盒子模型就是把HTML页面中的布局元素看作是一个矩形的盒子，也就是一个盛装内容的容器。盒子模型由元素的内容、边框（border）、内边距（padding）、和外边距（margin）组成。盒子里面的文字和图片等元素是 内容区域盒子的厚度 我们称为为盒子的边框盒子内容与边框的距离是内边距盒子与盒子之间的距离是外边距W3c标准盒子模型

标准 w3c 盒子模型的范围包括 margin、border、padding、content
当设置为box-sizing: content-box;时，将采用标准模式解析计算，也是默认模式；
内盒尺寸计算(元素实际大小)
宽度：Element Height &#x3D; content height + padding + border （Height为内容高度）高度：Element  Width &#x3D; content width + padding + border （Width为内容宽度）盒子的实际大小：内容的宽度和高度 +  内边距   +  边框  图片IE盒子模型IE 盒子模型的 content 部分包含了 border 和 pading
当设置为box-sizing: border-box时，将采用怪异模式解析计算；

盒子边框(border)属性	作用border-width	定义边框粗细，单位是pxborder-style	边框的样式border-color	边框颜色边框的样式：

none：没有边框即忽略所有边框的宽度（默认值）solid：边框为单实线(最为常用的)dashed：边框为虚线dotted：边框为点线边框综合设置border : border-width || border-style || border-color 
border: 1px solid red;  没有顺序要求盒子边框写法总结表：
很多情况下，我们不需要指定4个边框，我们是可以单独给4个边框分别指定的。
上边框	下边框	左边框	右边框border-top-style:样式;	border-bottom-style:样式;	border-left-style:样式;	border-right-style:样式;border-top-width:宽度;	border- bottom-width:宽度;	border-left-width:宽度;	border-right-width:宽度;border-top-color:颜色;	border- bottom-color:颜色;	border-left-color:颜色;	border-right-color:颜色;border-top:宽度 样式 颜色;	border-bottom:宽度 样式 颜色;	border-left:宽度 样式 颜色;	border-right:宽度 样式 颜色;表格的细线边框：
图片通过表格的cellspacing&#x3D;”0”,将单元格与单元格之间的距离设置为0，但是两个单元格之间的边框会出现重叠，从而使边框变粗通过css属性：table{ border-collapse:collapse; }collapse 单词是合并的意思,border-collapse: collapse;表示相邻边框合并在一起。

 table {
  width: 500px;
  height: 300px;
  border: 1px solid red;
 }
 td {
  border: 1px solid red;
  text-align: center;
 }
 table, td {
  border-collapse: collapse;  &#x2F;*合并相邻边框*&#x2F;
 }


内边距(padding)padding属性用于设置内边距。是指边框与内容之间的距离。

设置
属性	作用padding-left	左内边距padding-right	右内边距padding-top	上内边距padding-bottom	下内边距padding简写
值的个数	表达意思1个值	padding：上下左右内边距;2个值	padding: 上下内边距    左右内边距 ；3个值	padding：上内边距   左右内边距   下内边距；4个值	padding: 上内边距 右内边距 下内边距 左内边距 ；当我们给盒子指定padding值之后， 发生了2件事情：
内容和边框 有了距离，添加了内边距。盒子会变大解决措施：通过给设置了宽高的盒子，减去相应的内边距的值，维持盒子原有的大小。
padding不影响盒子大小情况：👉如果没有给一个盒子指定宽度， 此时，如果给这个盒子指定padding， 则不会撑开盒子。

外边距（margin）margin属性用于设置外边距。margin就是控制盒子和盒子之间的距离

设置
属性	作用margin-left	左外边距margin-right	右外边距margin-top	上外边距margin-bottom	下外边距margin值的简写 （复合写法）代表意思  跟 padding 完全相同。
块级盒子水平居中
盒子必须指定宽度（width）然后就给左右的外边距都设置为auto实际工作中常用这种方式进行网页布局，示例代码如下：
.header  { width: 960px; margin: 0 auto;}常见的写法，以下下三种都可以👇👇。
margin-left: auto;   margin-right: auto;margin: auto;margin: 0 auto;文字居中和盒子居中区别👇👇
盒子内的文字水平居中是 text-align: center; 而且还可以让 行内元素和行内块居中对齐块级盒子水平居中  左右margin 改为 auto插入图片和背景图片区别👇👇
插入图片我们用的最多 比如产品展示类  移动位置只能靠盒模型 padding margin背景图片我们一般用于小图标背景或者超大背景图片、背景图片，移动位置只能通过  background-position清除元素的默认内外边距👇👇
行内元素为了照顾兼容性,尽量只设置左右内外边距，不要设置上下内外边距。

{ padding:0;         &#x2F;* 清除内边距 &#x2F; margin:0;          &#x2F; 清除外边距 *&#x2F;}4.外边距合并使用margin定义块元素的「垂直外边距」时，可能会出现外边距的合并。

(1). 相邻块元素垂直外边距的合并当上下相邻的两个块元素相遇时，如果上面的元素有下外边距margin-bottom下面的元素有上外边距margin-top，则他们之间的垂直间距不是margin-bottom与margin-top之和「取两个值中的较大者」这种现象被称为相邻块元素垂直外边距的合并（也称外边距塌陷）。图片「解决方案：尽量给只给一个盒子添加margin值」。
(2). 嵌套块元素垂直外边距的合并（塌陷）对于两个嵌套关系的块元素，如果父元素没有上内边距及边框父元素的上外边距会与子元素的上外边距发生合并合并后的外边距为两者中的较大者图片「解决方案：」
可以为父元素定义上边框。可以为父元素定义上内边距可以为父元素添加overflow: hidden。还有其他方法，比如浮动、固定、绝对定位的盒子不会有问题，后面咱们再总结。。。
盒子模型布局稳定性优先使用  宽度 （width）  其次 使用内边距（padding）    再次  外边距（margin）
width &gt;  padding  &gt;   margin原因：
margin 会有外边距合并 还有 ie6下面margin 加倍的bug（讨厌）所以最后使用。padding  会影响盒子大小， 需要进行加减计算（麻烦） 其次使用。width   没有问题（嗨皮）我们经常使用宽度剩余法 高度剩余法来做。5. CSS3 新增圆角边框：
border-radius:length;
border-top-left-radius   定义了左上角的弧度border-top-right-radius   定义了右上角的弧度border-bottom-right-radius   定义了右下角的弧度border-bottom-left-radius   定义了左下角的弧度其中每一个值可以为 数值或百分比的形式。技巧：让一个正方形 变成圆圈border-radius: 50%;图片如果要在四个角上一一指定，可以使用以下规则👇👇：
border-radius: 左上角 右上角  右下角  左下角;四个值: 第一个值为左上角，第二个值为右上角，第三个值为右下角，第四个值为左下角。三个值: 第一个值为左上角, 第二个值为右上角和左下角，第三个值为右下角两个值: 第一个值为左上角与右下角，第二个值为右上角与左下角一个值：四个圆角值相同盒子阴影(box-shadow)：
box-shadow: offset-x offset-y [blur [spread]] [color] [inset]值	描述offset-x	阴影的水平偏移量。正数向右偏移，负数向左偏移。offset-y	阴影的垂直偏移量。正数向下偏移，负数向上偏移。blur	可选。阴影模糊距离，不能取负数。spread	可选。阴影大小color	可选。阴影的颜色inset	可选。表示添加内阴影，默认为外阴影div {   width: 200px;   height: 200px;   border: 10px solid red;   &#x2F;* box-shadow: 5px 5px 3px 4px rgba(0, 0, 0, .4);  &#x2F;   &#x2F; box-shadow:水平位置 垂直位置 模糊距离 阴影尺寸（影子大小） 阴影颜色  内&#x2F;外阴影； *&#x2F;   box-shadow: 0 15px 30px  rgba(0, 0, 0, .4);}
浮动浮动「1. CSS布局的三种机制」
网页布局的核心——就是用CSS来摆放盒子。
CSS 提供了3种机制来设置盒子的摆放位置，分别是普通流（标准流）、浮动和定位，其中：
A. 普通流（标准流）
块级元素会独占一行，从上向下顺序排列；常用元素：div、hr、p、h1~h6、ul、ol、dl、form、table行内元素会按照顺序，从左到右顺序排列，碰到父元素边缘则自动换行；常用元素：span、a、i、em等B. 浮动
让盒子从普通流中浮起来,主要作用让多个块级盒子一行显示。C. 定位
将盒子定在浏览器的某一个位置——CSS 离不开定位，特别是后面的 js 特效。「2. 什么是浮动」元素的浮动是指设置了浮动属性的元素会
脱离标准普通流的控制,不占位置，脱标移动到指定位置。作用让多个盒子(div)水平排列成一行，使得浮动称为布局的重要手段。可以实现盒子的左右对齐等等。浮动最早是用来控制图片，实现文字环绕图片效果。float属性会改变元素的display属性，任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。生成的块级框和我们前面的行内块极其相似。语法选择器 { float: 属性值; }属性值	描述none	元素不浮动（默认值）left	元素向左浮动right	元素向右浮动
浮动只会影响当前的或者是后面的标准流盒子，不会影响前面的标准流。建议:如果一个盒子里面有多个子盒子，如果其中一个盒子浮动了，其他兄弟也应该浮动。防止引起问题
图片浮动(float)小结
特点	说明浮	加了浮动的盒子「是浮起来」的，漂浮在其他标准流盒子的上面。漏	加了浮动的盒子「是不占位置的」，它原来的位置「漏给了标准流的盒子」。特	「特别注意」：浮动元素会改变display属性， 类似转换为了行内块，但是元素之间没有空白缝隙清除浮动因为父级盒子很多情况下，不方便给高度，但是子盒子浮动就不占有位置，最后父级盒子高度为0，就影响了下面的标准流盒子。图片图片总结：
由于浮动元素不再占用原文档流的位置，所以它会对后面的元素排版产生影响准确地说，并不是清除浮动，而是清除浮动后造成的影响清除浮动本质清除浮动主要为了解决父级元素因为子级浮动引起内部高度为0 的问题。清除浮动之后， 父级就会根据浮动的子盒子自动检测高度。父级有了高度，就不会影响下面的标准流了
清除浮动的方法选择器 { clear: 属性值; }   clear 清除属性值	描述left	不允许左侧有浮动元素（清除左侧浮动的影响）right	不允许右侧有浮动元素（清除右侧浮动的影响）both	同时清除左右两侧浮动的影响实际工作中,几乎只用clear: both
1).额外标签法(隔墙法)
是W3C推荐的做法是通过在浮动元素末尾添加一个空的标签例如 ，或则其他标签br等亦可。
优点：通俗易懂，书写方便缺点：添加许多无意义的标签，结构化较差。2).父级添加overflow属性方法
可以给父级添加： overflow为 hidden| auto| scroll  都可以实现。优点： 代码简洁缺点： 内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素。3).使用after伪元素清除浮动:after 方式为空元素额外标签法的升级版，好处是不用单独加标签了
.clearfix:after {
    content: &quot;&quot;;
    display: block;
    height: 0;
    clear: both;
    visibility: hidden;
}

&#x2F;* IE6、7 专有 *&#x2F;
.clearfix {
    *zoom: 1;
}
    

优点：符合闭合浮动思想  结构语义化正确缺点：由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。4).使用双伪元素清除浮动
.clearfix:before,
.clearfix:after {
    content: &quot;&quot;;
    display: table;
}

.clearfix:after {
    clear: both;
}

.clearfix {
   *zoom: 1;
}

优点： 代码更简洁缺点： 由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。清除浮动总结什么时候用清除浮动呢？
父级没高度子盒子浮动了影响下面布局了，我们就应该清除浮动了。
清除浮动的方式	优点	缺点额外标签法（隔墙法）	通俗易懂，书写方便	添加许多无意义的标签，结构化较差。父级overflow:hidden;	书写简单	溢出隐藏父级after伪元素	结构语义化正确	由于IE6-7不支持:after，兼容性问题父级双伪元素	结构语义化正确	由于IE6-7不支持:after，兼容性问题CSS属性书写顺序建议遵循以下顺序：
布局定位属性：display &#x2F; position &#x2F; float &#x2F; clear &#x2F; visibility &#x2F; overflow（建议 display 第一个写，毕竟关系到模式）
自身属性：width &#x2F; height &#x2F; margin &#x2F; padding &#x2F; border &#x2F; background
文本属性：color &#x2F; font &#x2F; text-decoration &#x2F; text-align &#x2F; vertical-align &#x2F; white- space &#x2F; break-word
其他属性（CSS3）：content &#x2F; cursor &#x2F; border-radius &#x2F; box-shadow &#x2F; text-shadow &#x2F; background:linear-gradient …
.jdc {    display: block;    position: relative;    float: left;    width: 100px;    height: 100px;    margin: 0 10px;    padding: 20px 0;    font-family: Arial, ‘Helvetica Neue’, Helvetica, sans-serif;    color: #333;    background: rgba(0,0,0,.5);    -webkit-border-radius: 10px;    -moz-border-radius: 10px;    -o-border-radius: 10px;    -ms-border-radius: 10px;    border-radius: 10px;}
定位(position)「1. 定位详解」
将盒子「定」在某一个「位」置  自由的漂浮在其他盒子(包括标准流和浮动)的上面。
所以，我们脑海应该有三种布局机制的上下顺序👇👇标准流在最底层 (海底)  ——-    浮动 的盒子 在 中间层  (海面)  ——-   定位的盒子 在 最上层  （天空）
定位是用来布局的，它有两部分组成：定位 &#x3D; 定位模式 + 边偏移在 CSS 中，通过 top、bottom、left 和 right 属性定义元素的「边偏移」：（方位名词）
边偏移属性	示例	描述top	top: 80px	「顶端」偏移量，定义元素相对于其父元素「上边线的距离」。bottom	bottom: 80px	「底部」偏移量，定义元素相对于其父元素「下边线的距离」。left	left: 80px	「左侧」偏移量，定义元素相对于其父元素「左边线的距离」。right	right: 80px	「右侧」偏移量，定义元素相对于其父元素「右边线的距离」图片「2. 定位模式(position)」在 CSS 中，通过 position 属性定义元素的「定位模式」，语法如下：
选择器 { position: 属性值; }值	语义static	「静态」定位relative	「相对」定位absolute	「绝对」定位fixed	「固定」定位「3. 静态定位(static)」
静态定位是元素的默认定位方式，无定位的意思。它相当于border里面的none，不要定位的时候用。静态定位 按照标准流特性摆放位置。它没有边偏移。静态定位在布局时几乎不用「4. 相对定位(relative)」
相对定位是元素相对于它原来在标准流中的位置来说的。图片相对于自己原来在标准流中位置来移动的原来在标准流的区域继续占有，后面的盒子仍然以标准流的方式对待它。「5. 绝对定位(absolute)」
绝对定位是元素以带有定位的父级元素来移动位置
完全脱表–完全不占位置；父元素没有定位，则以浏览器为准定位(Document文档)。图片父元素有定位图片定位口诀–子绝父相「6. 固定定位(fixed)」
固定定位是绝对定位的一种特殊形式;
完全脱标–完全不占位置；只认浏览器的可视窗口–浏览器可视窗口+边偏移属性来设置元素的位置跟父元素没有任何关系；单独使用不随滚动条滚动定位(position)的扩展绝对定位的盒子居中绝对定位&#x2F;固定定位的盒子不能通过设置margin: auto设置水平居中 在使用绝对定位时要向实现水平居中，可以按照下面的方法：
图片left : 50%:让盒子的左侧移动到父级元素的水平中心位置；margin-left: -100px;让盒子向左移动自身宽度的一半。同理垂直居中。堆叠顺序（z-index）在使用「定位」布局时，可能会「出现盒子重叠的情况」。
加了定位的盒子，默认「后来者居上」， 后面的盒子会压住前面的盒子。
应用 z-index 层叠等级属性可以「调整盒子的堆叠顺序」。如下图所示：
图片z-index的特性如下:
属性值：正整数、负整数或 0，默认值是 0，数值越大，盒子越靠上；如果属性值相同，则按照书写顺序，后来居上；数字后面不能加单位z-index只能用于相对定位、绝对定位和固定定位的元素，其他标准流、浮动和静态定位无效。定位改变display属性前面提过， display 是 显示模式， 可以通过以下方式改变显示模式:
可以用inline-block  转换为行内块可以用浮动 float 默认转换为行内块（类似，并不完全一样，因为浮动是脱标的）绝对定位和固定定位也和浮动类似， 默认转换的特性 转换为行内块。所以说， 一个行内的盒子，如果加了「浮动」、「固定定位」和「绝对定位」，不用转换，就可以给这个盒子直接设置宽度和高度等。
定位小结定位模式	是否脱标占有位置	移动位置基准	模式转换（行内块）	使用情况静态static	不脱标，正常模式	正常模式	不能	几乎不用相对定位relative	不脱标，占有位置	相对自身位置移动	不能	基本单独使用绝对定位absolute	完全脱标，不占有位置	相对于定位父级移动位置	能	要和定位父级元素搭配使用固定定位fixed	完全脱标，不占有位置	相对于浏览器移动位置	能	单独使用，不需要父级注意：
边偏移 需要和 定位模式 联合使用，单独使用无效；top 和 bottom 不要同时使用；left 和 right 不要同时使用。
CSS高级技巧元素的显示与隐藏目的:让一个元素在页面中消失或者显示出来
场景:类似网站广告，当我们点击关闭就不见了，但是我们重新刷新页面，会重新出现！
1.1 display 显示（重点）display设置或检索对象是否显示或如何显示。
display: none 隐藏对象特点：隐藏之后，不再保留位置。display: block 除了转换为块级元素之外，同时还有显示元素的意思。图片实际开发场景：配合后面js做特效，比如下拉菜单，原先没有，鼠标经过，显示下拉菜单， 应用极为广泛
1.2 visibility 可见性设置或检索是否显示对象
visibility：visible ;  对象可视
visibility：hidden;    对象隐藏特点：隐藏之后，继续保留原有位置。图片1.3 overflow 溢出检索或设置当对象的内容超过其指定高度及宽度时如何管理内容。
属性值	描述visible	不剪切内容也不添加滚动条hidden	不显示超过对象尺寸的内容，超出的部分隐藏掉scroll	不管超出内容否，总是显示滚动条auto	超出自动显示滚动条，不超出不显示滚动条图片实际开发场景：
清除浮动隐藏超出内容，隐藏掉,  不允许内容超过父盒子。1.4 显示与隐藏总结属性	区别	用途display	隐藏对象，不保留位置	配合后面js做特效，比如下拉菜单，原先没有，鼠标经过，显示下拉菜单， 应用极为广泛visibility	隐藏对象，保留位置	使用较少overflow	只是隐藏超出大小的部分	1. 可以清除浮动 2. 保证盒子里面的内容不会超出该盒子范围CSS用户界面样式所谓的界面样式， 就是更改一些用户操作样式，以便提高更好的用户体验。
更改用户的鼠标样式表单轮廓等。防止表单域拖拽2.1 鼠标样式设置或检索在对象上移动的鼠标指针采用何种系统预定义的光标形状。
属性值	描述default	小白  默认pointer	小手move	移动text	文本not-allowed	禁止

  我是小白
  我是小手
  我是移动
  我是文本
  我是文本

2.2 轮廓线 outline
图片是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。

outline : outline-color ||outline-style || outline-width但是我们都不关心可以设置多少，我们平时都是去掉的。最直接的写法是 ： outline: 0;   或者   outline: none;
2.3 防止拖拽文本域resize图片

2.4 用户界面样式总结属性	用途	用途鼠标样式	更改鼠标样式cursor	样式很多，重点记住 pointer轮廓线	表单默认outline	outline 轮廓线，我们一般直接去掉，border是边框，我们会经常用防止拖拽	主要针对文本域resize	防止用户随意拖拽文本域，造成页面布局混乱，我们resize:nonevertical-align 垂直对齐有宽度的块级元素居中对齐，是margin: 0 auto;让文字居中对齐，是 text-align: center;vertical-align 垂直对齐，它只针对于「行内元素」或者「行内块元素」
图片设置或检索对象内容的垂直对其方式。vertical-align : baseline |top |middle |bottom注意：
vertical-align 不影响块级元素中的内容对齐，它只针对于「行内元素」或者「行内块元素」，
特别是行内块元素， 通常用来控制图片&#x2F;表单与文字的对齐。
3.1 图片、表单和文字对齐我们可以通过vertical-align 控制图片和文字的垂直关系了。默认的图片会和文字基线对齐。
图片图片3.2 去除图片底侧空白缝隙图片原因：图片或者表单等行内块元素，他的底线会和父级盒子的基线对齐。
就是图片底侧会有一个空白缝隙。
解决方法：
给img vertical-align:middle | top| bottom等等。 让图片不要和基线对齐。图片给img 添加 display：block; 转换为块级元素就不会存在问题了。溢出的文字省略号显示4.1 white-spacewhite-space设置或检索对象内文本显示方式。通常我们使用于强制一行显示内容white-space:normal ；默认处理方式
white-space:nowrap ； 强制在同一行内显示所有文本，直到文本结束或者遭遇br标签对象才换行。4.2 text-overflow 文字溢出设置或检索是否使用一个省略标记（…）标示对象内文本的溢出text-overflow : clip ；不显示省略标记（…），而是简单的裁切 
text-overflow：ellipsis ； 当对象内文本溢出时显示省略标记（…）「注意」：
一定要首先强制一行内显示，再次和overflow属性  搭配使用
图片4.3 总结三步曲  &#x2F;1. 先强制一行内显示文本&#x2F;      white-space: nowrap;  &#x2F;2. 超出的部分隐藏&#x2F;      overflow: hidden;  &#x2F;3. 文字用省略号替代超出的部分&#x2F;      text-overflow: ellipsis;CSS精灵技术（sprite)CSS精灵技术（也称CSS Sprites、CSS雪碧）。图片
图所示为网页的请求原理图，当用户访问一个网站时，需要向服务器发送请求，网页上的每张图像都要经过一次请求才能展现给用户。然而，一个网页中往往会应用很多小的背景图像作为修饰，当网页中的图像过多时，服务器就会频繁地接受和发送请求，这将大大降低页面的加载速度。为什么需要精灵技术：为了有效地减少服务器接受和发送请求的次数，提高页面的加载速度。
5.1 精灵技术讲解CSS 精灵其实是将网页中的一些背景图像整合到一张大图中（精灵图），然而，各个网页元素通常只需要精灵图中不同位置的某个小图，要想精确定位到精灵图中的某个小图。
图片这样，当用户访问该页面时，只需向服务发送一次请求，网页中的背景图像即可全部展示出来。
我们需要使用CSS的:
background-image、background-repeatbackground-position属性进行背景定位，其中最关键的是使用background-position 属性精确地定位。5.2 精灵技术使用的核心总结首先我们知道，css精灵技术主要针对于背景图片，插入的图片img 是不需要这个技术的。
精确测量，每个小背景图片的大小和 位置。给盒子指定小背景图片时， 背景定位基本都是 负值。滑动门图片6.1 滑动门出现的背景制作网页时，为了美观，常常需要为网页元素设置特殊形状的背景，比如微信导航栏，有凸起和凹下去的感觉，最大的问题是里面的字数不一样多，咋办？
图片为了使各种特殊形状的背景能够自适应元素中文本内容的多少，出现了CSS滑动门技术。它从新的角度构建页面，使各种特殊形状的背景能够自由拉伸滑动，以适应元素内部的文本内容，可用性更强。最常见于各种导航栏的滑动门。
6.2 核心技术核心技术就是利用CSS精灵（主要是背景位置）和 盒子padding撑开宽度, 以便能适应不同字数的导航栏。
一般的经典布局都是这样的：

  
    导航栏内容
  

* {
    padding:0;
    margin:0;

   }    body{      background: url(images&#x2F;wx.jpg) repeat-x;    }    .father {      padding-top:20px;    }    li {      padding-left: 16px;      height: 33px;      float: left;      line-height: 33px;      margin:0  10px;      background: url(.&#x2F;images&#x2F;to.png) no-repeat left ;    }    a {      padding-right: 16px;      height: 33px;      display: inline-block;      color:#fff;      background: url(.&#x2F;images&#x2F;to.png) no-repeat right ;      text-decoration: none;    }    li:hover,    li:hover a {      background-image:url(.&#x2F;images&#x2F;ao.png);    }总结：
a 设置 背景左侧，padding撑开合适宽度。span 设置背景右侧， padding撑开合适宽度 剩下由文字继续撑开宽度。之所以a包含span就是因为 整个导航都是可以点击的。CSS 三角形div {
width: 0; 

height: 0;
line-height:0；
font-size: 0;

   border-top: 10px solid red;
   border-right: 10px solid green;
   border-bottom: 10px solid blue;
   border-left: 10px solid #000; 
 }

图片我们用css 边框可以模拟三角效果宽度高度为0我们4个边框都要写， 只保留需要的边框颜色，其余的不能省略，都改为 transparent 透明就好了为了照顾兼容性 低版本的浏览器，加上 font-size: 0;  line-height: 0;
</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/02/17/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87/" title="第一篇文"><img src="https://s2.loli.net/2022/03/28/zXHY3nC2V7vguRT.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第一篇文"/></a><div class="content"><a class="title" href="/2023/02/17/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87/" title="第一篇文">第一篇文</a><time datetime="2023-02-17T01:17:54.074Z" title="发表于 2023-02-17 09:17:54">2023-02-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/17/hello-world/" title="Hello World"><img src="https://s2.loli.net/2022/03/28/zXHY3nC2V7vguRT.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="/2023/02/17/hello-world/" title="Hello World">Hello World</a><time datetime="2023-02-17T01:03:09.635Z" title="发表于 2023-02-17 09:03:09">2023-02-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/15/%E5%85%B3%E4%BA%8E%E6%9F%90%E4%BA%91%E9%9F%B3%E4%B9%90%E8%A7%A3%E7%81%B0%E5%B7%A5%E5%85%B7%E7%9A%84%E5%88%9D%E4%BD%93%E9%AA%8C/" title="「netease」关于某云音乐解灰工具的初体验"><img src="https://s2.loli.net/2022/03/28/zXHY3nC2V7vguRT.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="「netease」关于某云音乐解灰工具的初体验"/></a><div class="content"><a class="title" href="/2023/02/15/%E5%85%B3%E4%BA%8E%E6%9F%90%E4%BA%91%E9%9F%B3%E4%B9%90%E8%A7%A3%E7%81%B0%E5%B7%A5%E5%85%B7%E7%9A%84%E5%88%9D%E4%BD%93%E9%AA%8C/" title="「netease」关于某云音乐解灰工具的初体验">「netease」关于某云音乐解灰工具的初体验</a><time datetime="2023-02-15T12:13:00.000Z" title="发表于 2023-02-15 20:13:00">2023-02-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/20/2023%E8%80%83%E7%A0%94%E6%95%B0%E4%BA%8C%E8%B5%84%E6%96%99%E5%88%86%E4%BA%AB/" title="「一研为定」23数二辅导书pdf分享"><img src="https://s2.loli.net/2022/03/28/zXHY3nC2V7vguRT.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="「一研为定」23数二辅导书pdf分享"/></a><div class="content"><a class="title" href="/2022/04/20/2023%E8%80%83%E7%A0%94%E6%95%B0%E4%BA%8C%E8%B5%84%E6%96%99%E5%88%86%E4%BA%AB/" title="「一研为定」23数二辅导书pdf分享">「一研为定」23数二辅导书pdf分享</a><time datetime="2022-04-20T11:30:00.000Z" title="发表于 2022-04-20 19:30:00">2022-04-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/14/%E8%A7%86%E9%A2%91%E8%A7%A3%E6%9E%90/" title="「油猴脚本」各大网页VIP视频解析（截止4.14稳定运行）"><img src="https://s2.loli.net/2022/03/28/zXHY3nC2V7vguRT.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="「油猴脚本」各大网页VIP视频解析（截止4.14稳定运行）"/></a><div class="content"><a class="title" href="/2022/04/14/%E8%A7%86%E9%A2%91%E8%A7%A3%E6%9E%90/" title="「油猴脚本」各大网页VIP视频解析（截止4.14稳定运行）">「油猴脚本」各大网页VIP视频解析（截止4.14稳定运行）</a><time datetime="2022-04-14T10:13:00.000Z" title="发表于 2022-04-14 18:13:00">2022-04-14</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://s2.loli.net/2022/03/28/zXHY3nC2V7vguRT.png')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By Sterling</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="nav-music"><div id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()">播放音乐</div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script src="/js/script.js"></script><script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script><script src="/js/APlayer.min.js"></script><script src="/js/Meting2.min.js"></script><script async data-pjax src="/js/anzhiyu.js"></script><script async data-pjax src="/js/anzhiyufunction.js"></script><script async src="/js/anzhiyuOnlyOne.js"></script><script async data-pjax src="/js/anzhiyu2.js"></script><script src="/js/music.js"></script><script src="/js/zhihu.js"></script><script async data-pjax src="/js/card_author.js"></script><link rel="stylesheet" href="/css/APlayer.min.css" media="print" onload="this.media='all'"><script src="/js/APlayer.min.js"></script><script src="/js/Meting2.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var qweather_key = 'b16a1fa0e63c46a4b8f28abfb06ae3fe';
  var gaud_map_key = 'e2b04289e870b005374ee030148d64fd&s=rsv3';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '112.982279,28.19409';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><!-- hexo injector body_end end --></body></html>